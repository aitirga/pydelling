{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index","title":"Index"},{"location":"#index","text":"","title":"Index"},{"location":"docs-getting_started/","text":"Getting Started","title":"Getting started"},{"location":"docs-getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"docs-installation/","text":"Installation","title":"Installation"},{"location":"docs-installation/#installation","text":"","title":"Installation"},{"location":"docs-usage/","text":"Usage","title":"Usage examples"},{"location":"docs-usage/#usage","text":"","title":"Usage"},{"location":"interpolation/docs-interpolation-kde/","text":"KdeEstimator This class performs a KDE estimation on a given dataset and provides useful methods to plot and manipulate the estimated distributions. Source code in pydelling/interpolation/KdeEstimator.py class KdeEstimator : \"\"\" This class performs a KDE estimation on a given dataset and provides useful methods to plot and manipulate the estimated distributions. \"\"\" is_run : bool kde_estimator : KernelDensity def __init__ ( self , data : pd . DataFrame = None , kernel = 'gaussian' , bandwidth = 1000 , package = 'scikit' ): self . data = data self . kernel = kernel self . bandwidth = bandwidth self . package = package if type ( self . data ) == pd . Series : self . data = pd . DataFrame ( self . data ) @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator def plot_1d_comparison_histograms ( self , variable = None , n = 10000 , savefig = None , bins = 30 , colors = None , xlabel = None , ylabel = None ): plt . clf () fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes if not variable : variable = self . data . columns [ 0 ] sampled_values = pd . DataFrame ( self . kde_estimator . sample ( n ), columns = self . data . columns ) ax . hist ( self . data [ variable ] . values , bins = bins , density = True , alpha = 0.5 , label = variable , color = colors [ 0 ] if colors else 'C0' ) ax . hist ( sampled_values [ variable ] . values , bins = bins , density = True , alpha = 0.5 , label = f \" { variable } -kde\" , color = colors [ 1 ] if colors else 'C1' ) ax . set_axisbelow ( True ) if xlabel : ax . set_xlabel ( xlabel ) if ylabel : ax . set_ylabel ( ylabel ) plt . legend () plt . grid () if savefig : plt . savefig ( savefig ) else : plt . show () return ax def plot_1d_comparison_histograms_multi ( self , variables , n = 10000 , savefig = None , bins = 30 , palette = None , dpi = 150 ): plt . clf () fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes sampled_values = pd . DataFrame ( self . kde_estimator . sample ( n ), columns = self . data . columns ) for idx , variable in enumerate ( variables ): if palette : color = palette [ idx ] sns . histplot ( self . data [ variable ] . values , bins = bins , alpha = 0.75 , label = variable , color = color if palette else {} ) sns . histplot ( sampled_values [ variable ] . values , bins = bins , alpha = 0.25 , label = f \" { variable } -kde\" , color = color if palette else {} ) ax . set_axisbelow ( True ) plt . legend () plt . grid () if savefig : plt . savefig ( savefig , dpi = dpi ) else : plt . show () return ax def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax @property def _training_data ( self ): assert not self . data . empty , 'Provide some data to work with' return self . data . values . reshape ( - 1 , self . data . shape [ 1 ]) def sample ( self , * args , ** kwargs ): return self . kde_estimator . sample ( * args , ** kwargs ) plot_1d ( self , variable = None , n = 100 , savefig = None ) Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot Source code in pydelling/interpolation/KdeEstimator.py def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax run ( self , data = None ) Fit the provided dataset to the corresponding kernel distribution Source code in pydelling/interpolation/KdeEstimator.py @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator","title":"KDE estimator"},{"location":"interpolation/docs-interpolation-kde/#pydelling.interpolation.KdeEstimator.KdeEstimator","text":"This class performs a KDE estimation on a given dataset and provides useful methods to plot and manipulate the estimated distributions. Source code in pydelling/interpolation/KdeEstimator.py class KdeEstimator : \"\"\" This class performs a KDE estimation on a given dataset and provides useful methods to plot and manipulate the estimated distributions. \"\"\" is_run : bool kde_estimator : KernelDensity def __init__ ( self , data : pd . DataFrame = None , kernel = 'gaussian' , bandwidth = 1000 , package = 'scikit' ): self . data = data self . kernel = kernel self . bandwidth = bandwidth self . package = package if type ( self . data ) == pd . Series : self . data = pd . DataFrame ( self . data ) @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator def plot_1d_comparison_histograms ( self , variable = None , n = 10000 , savefig = None , bins = 30 , colors = None , xlabel = None , ylabel = None ): plt . clf () fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes if not variable : variable = self . data . columns [ 0 ] sampled_values = pd . DataFrame ( self . kde_estimator . sample ( n ), columns = self . data . columns ) ax . hist ( self . data [ variable ] . values , bins = bins , density = True , alpha = 0.5 , label = variable , color = colors [ 0 ] if colors else 'C0' ) ax . hist ( sampled_values [ variable ] . values , bins = bins , density = True , alpha = 0.5 , label = f \" { variable } -kde\" , color = colors [ 1 ] if colors else 'C1' ) ax . set_axisbelow ( True ) if xlabel : ax . set_xlabel ( xlabel ) if ylabel : ax . set_ylabel ( ylabel ) plt . legend () plt . grid () if savefig : plt . savefig ( savefig ) else : plt . show () return ax def plot_1d_comparison_histograms_multi ( self , variables , n = 10000 , savefig = None , bins = 30 , palette = None , dpi = 150 ): plt . clf () fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes sampled_values = pd . DataFrame ( self . kde_estimator . sample ( n ), columns = self . data . columns ) for idx , variable in enumerate ( variables ): if palette : color = palette [ idx ] sns . histplot ( self . data [ variable ] . values , bins = bins , alpha = 0.75 , label = variable , color = color if palette else {} ) sns . histplot ( sampled_values [ variable ] . values , bins = bins , alpha = 0.25 , label = f \" { variable } -kde\" , color = color if palette else {} ) ax . set_axisbelow ( True ) plt . legend () plt . grid () if savefig : plt . savefig ( savefig , dpi = dpi ) else : plt . show () return ax def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax @property def _training_data ( self ): assert not self . data . empty , 'Provide some data to work with' return self . data . values . reshape ( - 1 , self . data . shape [ 1 ]) def sample ( self , * args , ** kwargs ): return self . kde_estimator . sample ( * args , ** kwargs )","title":"KdeEstimator"},{"location":"interpolation/docs-interpolation-kde/#pydelling.interpolation.KdeEstimator.KdeEstimator.plot_1d","text":"Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot Source code in pydelling/interpolation/KdeEstimator.py def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax","title":"plot_1d()"},{"location":"interpolation/docs-interpolation-kde/#pydelling.interpolation.KdeEstimator.KdeEstimator.run","text":"Fit the provided dataset to the corresponding kernel distribution Source code in pydelling/interpolation/KdeEstimator.py @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator","title":"run()"},{"location":"interpolation/docs-interpolation-sparse/","text":"Interpolates a given set of points into a PFLOTRAN mesh SparseDataInterpolator ( BaseInterpolator ) Source code in pydelling/interpolation/SparseDataInterpolator.py class SparseDataInterpolator ( BaseInterpolator ): divide_over_direction = None @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data () def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 ) def change_min_value ( self , min_value = None ): logger . info ( f \"Equaling values < { min_value } to { min_value } \" ) self . interpolated_data [ self . interpolated_data < min_value ] = min_value return self . interpolated_data def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data () def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' ) export_pointwise_data ( self , output_file = 'pointwise_data.csv' ) Exports the interpolated data to a csv data file Source code in pydelling/interpolation/SparseDataInterpolator.py def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' ) generate_pointwise_data ( self ) Generates a pointwise data file Source code in pydelling/interpolation/SparseDataInterpolator.py def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data get_data ( self ) Returns interpolated data :return: Source code in pydelling/interpolation/SparseDataInterpolator.py def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 ) plot_regular_mesh ( self ) Generates a plot of the interpolated data on a regular mesh Source code in pydelling/interpolation/SparseDataInterpolator.py def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data () run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ) Interpolates the data using the given method. Parameters: Name Type Description Default method interpolation method 'nearest' divide_over_direction Divides the data into smaller chunks if the data is too large. None **kwargs {} Returns: Type Description interpolated data Source code in pydelling/interpolation/SparseDataInterpolator.py @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data ()","title":"Docs interpolation sparse"},{"location":"interpolation/docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator","text":"Source code in pydelling/interpolation/SparseDataInterpolator.py class SparseDataInterpolator ( BaseInterpolator ): divide_over_direction = None @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data () def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 ) def change_min_value ( self , min_value = None ): logger . info ( f \"Equaling values < { min_value } to { min_value } \" ) self . interpolated_data [ self . interpolated_data < min_value ] = min_value return self . interpolated_data def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data () def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' )","title":"SparseDataInterpolator"},{"location":"interpolation/docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.export_pointwise_data","text":"Exports the interpolated data to a csv data file Source code in pydelling/interpolation/SparseDataInterpolator.py def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' )","title":"export_pointwise_data()"},{"location":"interpolation/docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.generate_pointwise_data","text":"Generates a pointwise data file Source code in pydelling/interpolation/SparseDataInterpolator.py def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data","title":"generate_pointwise_data()"},{"location":"interpolation/docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.get_data","text":"Returns interpolated data :return: Source code in pydelling/interpolation/SparseDataInterpolator.py def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 )","title":"get_data()"},{"location":"interpolation/docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.plot_regular_mesh","text":"Generates a plot of the interpolated data on a regular mesh Source code in pydelling/interpolation/SparseDataInterpolator.py def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data ()","title":"plot_regular_mesh()"},{"location":"interpolation/docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.run","text":"Interpolates the data using the given method. Parameters: Name Type Description Default method interpolation method 'nearest' divide_over_direction Divides the data into smaller chunks if the data is too large. None **kwargs {} Returns: Type Description interpolated data Source code in pydelling/interpolation/SparseDataInterpolator.py @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data ()","title":"run()"},{"location":"paraview_processor/docs-paraview-filters-append_arc_length/","text":"AppendArcLengthFilter ( BaseFilter ) This class implements the Append Arc-Length filter Source code in pydelling/paraview_processor/filters/AppendArcLengthFilter.py class AppendArcLengthFilter ( BaseFilter ): \"\"\" This class implements the Append Arc-Length filter \"\"\" filter_type : str = \"Append_arc_length\" counter : int = 0 def __init__ ( self , input_filter , name ): super () . __init__ ( name = name ) AppendArcLengthFilter . counter += 1 self . filter = AppendArcLength ( Input = input_filter )","title":"AppendArcLength"},{"location":"paraview_processor/docs-paraview-filters-append_arc_length/#pydelling.paraview_processor.filters.AppendArcLengthFilter.AppendArcLengthFilter","text":"This class implements the Append Arc-Length filter Source code in pydelling/paraview_processor/filters/AppendArcLengthFilter.py class AppendArcLengthFilter ( BaseFilter ): \"\"\" This class implements the Append Arc-Length filter \"\"\" filter_type : str = \"Append_arc_length\" counter : int = 0 def __init__ ( self , input_filter , name ): super () . __init__ ( name = name ) AppendArcLengthFilter . counter += 1 self . filter = AppendArcLength ( Input = input_filter )","title":"AppendArcLengthFilter"},{"location":"paraview_processor/docs-paraview-filters-calculator/","text":"CalculatorFilter ( BaseFilter ) Source code in pydelling/paraview_processor/filters/CalculatorFilter.py class CalculatorFilter ( BaseFilter ): filter_type : str = \"Calculator\" counter : int = 0 def __init__ ( self , input_filter , function , name , output_array_name = None , attribute_type = 'Cell Data' ): super () . __init__ ( name = name ) CalculatorFilter . counter += 1 self . filter = Calculator ( Input = input_filter ) self . filter . Function = function self . filter . AttributeType = attribute_type if output_array_name : self . filter . ResultArrayName = output_array_name def set_attribute_type ( self , attribute_type ): self . filter . AttributeType = attribute_type def set_function ( self , function ): self . filter . Function = function @property def calculation ( self ): \"\"\" This property returns the calculated array Returns: The array containing the calculation \"\"\" if self . filter . AttributeType == \"Cell Data\" : return self . cell_data [ self . filter . ResultArrayName ] if self . filter . AttributeType == \"Point Data\" : return self . point_data [ self . filter . ResultArrayName ] calculation property readonly This property returns the calculated array Returns: Type Description The array containing the calculation","title":"Calculator"},{"location":"paraview_processor/docs-paraview-filters-calculator/#pydelling.paraview_processor.filters.CalculatorFilter.CalculatorFilter","text":"Source code in pydelling/paraview_processor/filters/CalculatorFilter.py class CalculatorFilter ( BaseFilter ): filter_type : str = \"Calculator\" counter : int = 0 def __init__ ( self , input_filter , function , name , output_array_name = None , attribute_type = 'Cell Data' ): super () . __init__ ( name = name ) CalculatorFilter . counter += 1 self . filter = Calculator ( Input = input_filter ) self . filter . Function = function self . filter . AttributeType = attribute_type if output_array_name : self . filter . ResultArrayName = output_array_name def set_attribute_type ( self , attribute_type ): self . filter . AttributeType = attribute_type def set_function ( self , function ): self . filter . Function = function @property def calculation ( self ): \"\"\" This property returns the calculated array Returns: The array containing the calculation \"\"\" if self . filter . AttributeType == \"Cell Data\" : return self . cell_data [ self . filter . ResultArrayName ] if self . filter . AttributeType == \"Point Data\" : return self . point_data [ self . filter . ResultArrayName ]","title":"CalculatorFilter"},{"location":"paraview_processor/docs-paraview-filters-calculator/#pydelling.paraview_processor.filters.CalculatorFilter.CalculatorFilter.calculation","text":"This property returns the calculated array Returns: Type Description The array containing the calculation","title":"calculation"},{"location":"paraview_processor/docs-paraview-filters-cell_data_to_point_data/","text":"CellDataToPointDataFilter ( BaseFilter ) This class implements the Paraview Integrate Variables filter Source code in pydelling/paraview_processor/filters/CellDataToPointDataFilter.py class CellDataToPointDataFilter ( BaseFilter ): \"\"\" This class implements the Paraview Integrate Variables filter \"\"\" filter_type : str = \"Cell_data_to_point_data\" counter : int = 0 def __init__ ( self , input_filter , name ): super () . __init__ ( name = name ) CellDataToPointDataFilter . counter += 1 self . filter = CellDatatoPointData ( Input = input_filter )","title":"CellDataToPointData"},{"location":"paraview_processor/docs-paraview-filters-cell_data_to_point_data/#pydelling.paraview_processor.filters.CellDataToPointDataFilter.CellDataToPointDataFilter","text":"This class implements the Paraview Integrate Variables filter Source code in pydelling/paraview_processor/filters/CellDataToPointDataFilter.py class CellDataToPointDataFilter ( BaseFilter ): \"\"\" This class implements the Paraview Integrate Variables filter \"\"\" filter_type : str = \"Cell_data_to_point_data\" counter : int = 0 def __init__ ( self , input_filter , name ): super () . __init__ ( name = name ) CellDataToPointDataFilter . counter += 1 self . filter = CellDatatoPointData ( Input = input_filter )","title":"CellDataToPointDataFilter"},{"location":"paraview_processor/docs-paraview-filters-clip/","text":"ClipFilter ( BaseFilter ) This class implements the Paraview Integrate Variables filter Source code in pydelling/paraview_processor/filters/ClipFilter.py class ClipFilter ( BaseFilter ): \"\"\" This class implements the Paraview Integrate Variables filter \"\"\" filter_type : str = \"Clip\" counter : int = 0 def __init__ ( self , input_filter , name , * args , ** kwargs ): super () . __init__ ( name = name ) ClipFilter . counter += 1 self . filter = Clip ( Input = input_filter ) for kwarg in kwargs : setattr ( self . filter , kwarg , kwargs [ kwarg ]) def clip_box ( self , box_position , box_length , exact = True ): \"\"\" This method clips a box like domain into the filter Args: box_position: bottom left corner coordinates of the box. box_length: length vector of the box. exact: if true, the box will clip exactly the source filter. \"\"\" self . filter . ClipType = 'Box' self . filter . ClipType . Position = box_position self . filter . ClipType . Length = box_length self . filter . Exact = exact clip_box ( self , box_position , box_length , exact = True ) This method clips a box like domain into the filter Parameters: Name Type Description Default box_position bottom left corner coordinates of the box. required box_length length vector of the box. required exact if true, the box will clip exactly the source filter. True Source code in pydelling/paraview_processor/filters/ClipFilter.py def clip_box ( self , box_position , box_length , exact = True ): \"\"\" This method clips a box like domain into the filter Args: box_position: bottom left corner coordinates of the box. box_length: length vector of the box. exact: if true, the box will clip exactly the source filter. \"\"\" self . filter . ClipType = 'Box' self . filter . ClipType . Position = box_position self . filter . ClipType . Length = box_length self . filter . Exact = exact","title":"Clip"},{"location":"paraview_processor/docs-paraview-filters-clip/#pydelling.paraview_processor.filters.ClipFilter.ClipFilter","text":"This class implements the Paraview Integrate Variables filter Source code in pydelling/paraview_processor/filters/ClipFilter.py class ClipFilter ( BaseFilter ): \"\"\" This class implements the Paraview Integrate Variables filter \"\"\" filter_type : str = \"Clip\" counter : int = 0 def __init__ ( self , input_filter , name , * args , ** kwargs ): super () . __init__ ( name = name ) ClipFilter . counter += 1 self . filter = Clip ( Input = input_filter ) for kwarg in kwargs : setattr ( self . filter , kwarg , kwargs [ kwarg ]) def clip_box ( self , box_position , box_length , exact = True ): \"\"\" This method clips a box like domain into the filter Args: box_position: bottom left corner coordinates of the box. box_length: length vector of the box. exact: if true, the box will clip exactly the source filter. \"\"\" self . filter . ClipType = 'Box' self . filter . ClipType . Position = box_position self . filter . ClipType . Length = box_length self . filter . Exact = exact","title":"ClipFilter"},{"location":"paraview_processor/docs-paraview-filters-clip/#pydelling.paraview_processor.filters.ClipFilter.ClipFilter.clip_box","text":"This method clips a box like domain into the filter Parameters: Name Type Description Default box_position bottom left corner coordinates of the box. required box_length length vector of the box. required exact if true, the box will clip exactly the source filter. True Source code in pydelling/paraview_processor/filters/ClipFilter.py def clip_box ( self , box_position , box_length , exact = True ): \"\"\" This method clips a box like domain into the filter Args: box_position: bottom left corner coordinates of the box. box_length: length vector of the box. exact: if true, the box will clip exactly the source filter. \"\"\" self . filter . ClipType = 'Box' self . filter . ClipType . Position = box_position self . filter . ClipType . Length = box_length self . filter . Exact = exact","title":"clip_box()"},{"location":"paraview_processor/docs-paraview-filters-stream_tracer_with_custom_source/","text":"StreamTracerWithCustomSourceFilter ( BaseFilter ) This class implements the Stream Tracer with custom source filter Source code in pydelling/paraview_processor/filters/StreamTracerWithCustomSourceFilter.py class StreamTracerWithCustomSourceFilter ( BaseFilter ): \"\"\" This class implements the Stream Tracer with custom source filter \"\"\" filter_type : str = \"Stream_tracer_with_custom_source\" counter : int = 0 def __init__ ( self , input_filter , seed_source , name ): super () . __init__ ( name = name ) StreamTracerWithCustomSourceFilter . counter += 1 self . filter = StreamTracerWithCustomSource ( Input = input_filter ) self . filter . SeedSource = seed_source def set_seed_source ( self , seed_source ): self . filter . SeedSource = seed_source def add_vector ( self , vector_name ): self . filter . Vectors = [ 'POINTS' , vector_name ] def add_minimum_step_length ( self , minimum_step_length ): self . filter . MinimumStepLength = minimum_step_length","title":"StreamTracerWithCustomSource"},{"location":"paraview_processor/docs-paraview-filters-stream_tracer_with_custom_source/#pydelling.paraview_processor.filters.StreamTracerWithCustomSourceFilter.StreamTracerWithCustomSourceFilter","text":"This class implements the Stream Tracer with custom source filter Source code in pydelling/paraview_processor/filters/StreamTracerWithCustomSourceFilter.py class StreamTracerWithCustomSourceFilter ( BaseFilter ): \"\"\" This class implements the Stream Tracer with custom source filter \"\"\" filter_type : str = \"Stream_tracer_with_custom_source\" counter : int = 0 def __init__ ( self , input_filter , seed_source , name ): super () . __init__ ( name = name ) StreamTracerWithCustomSourceFilter . counter += 1 self . filter = StreamTracerWithCustomSource ( Input = input_filter ) self . filter . SeedSource = seed_source def set_seed_source ( self , seed_source ): self . filter . SeedSource = seed_source def add_vector ( self , vector_name ): self . filter . Vectors = [ 'POINTS' , vector_name ] def add_minimum_step_length ( self , minimum_step_length ): self . filter . MinimumStepLength = minimum_step_length","title":"StreamTracerWithCustomSourceFilter"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/","text":"Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py class DfnPreprocessor ( object ): dfn : List [ Fracture ] = [] def __getitem__ ( self , item ): return self . dfn [ item ] def __init__ ( self ): self . clean_dfn () def clean_dfn ( self ): \"\"\"Removes dfn object\"\"\" self . dfn = [] def load_fractures ( self , pd_df : pd , dip = 'dip' , dip_dir = 'dip-direction' , x = 'position-x' , y = 'position-y' , z = 'position-z' , size = 'size' , ): \"\"\" Loads the fractures from a pandas dataframe to the dfn object. Args: pd_df: pandas dataframe containing the fractures Returns: \"\"\" for index , row in tqdm ( pd_df . iterrows ()): self . add_fracture ( dip = row [ dip ], dip_dir = row [ dip_dir ], x = row [ x ], y = row [ y ], z = row [ z ], size = row [ size ] ) def add_fracture ( self , x , y , z , dip = None , dip_dir = None , size = None , aperture = None ): \"\"\"Add individual fracture to the dfn object. \"\"\" self . dfn . append ( Fracture ( dip = dip , dip_dir = dip_dir , x = x , y = y , z = z , size = size , aperture = aperture )) def summary ( self ): \"\"\"Prints a summary of the dfn object.\"\"\" print ( tabulate ( [ [ 'Number of fractures' , len ( self . dfn )], [ 'Max size' , f \" { self . max_size : 1.2f } m\" ], [ 'Min size' , f \" { self . min_size : 1.2f } m\" ] ], headers = [ 'Parameter' , 'Value' ], tablefmt = 'grid' , numalign = 'center' , )) def __len__ ( self ): return len ( self . dfn ) def visualize_dfn ( self , add_centroid = True , fracture_color = 'blue' , size_color = False ): \"\"\"Visualizes the dfn object.\"\"\" self . fig = self . generate_dfn_plotly ( add_centroid = add_centroid , fracture_color = fracture_color , size_color = size_color ) self . fig . show () def export_dfn_image ( self , filename = 'dfn.png' , add_centroid = True , fracture_color = 'blue' , * args , ** kwargs , ): logger . info ( f 'Exporting dfn image to { filename } ' ) self . fig = self . generate_dfn_plotly ( add_centroid = add_centroid , fracture_color = fracture_color ) self . fig . write_image ( filename , * args , ** kwargs ) def to_obj ( self , filename = 'dfn.obj' , method = 'v2' ): '''Exports the dfn object to stl format.''' logger . info ( f 'Exporting dfn object to { filename } ' ) obj_file = open ( filename , 'w' ) obj_file . write ( '# Created by pydelling \\n ' ) obj_file . write ( 'o dfn \\n ' ) global_id = 1 for fracture in tqdm ( self . dfn ): obj_file . write ( fracture . to_obj ( global_id = global_id , method = method )) global_id += fracture . side_points def to_dfnworks ( self , filename = 'dfn.dat' , method = 'v2' ): '''Exports the dfn object to dfnworks format.''' logger . info ( f 'Exporting dfn object to { filename } ' ) dfn_file = open ( filename , 'w' ) n_total_fractures = len ( self . dfn ) dfn_file . write ( f 'nPolygons: { n_total_fractures } \\n ' ) for fracture in tqdm ( self . dfn ): side_points = fracture . get_side_points ( method = method ) dfn_file . write ( f ' { len ( side_points ) } ' ) for point in side_points : dfn_file . write ( f ' {{ { point [ 0 ] } , { point [ 1 ] } , { point [ 2 ] } }} ' ) dfn_file . write ( ' \\n ' ) def shift_dfn ( self , x_shift = 0 , y_shift = 0 , z_shift = 0 ): \"\"\"Shifts the dfn object.\"\"\" for fracture in self . dfn : fracture . x_centroid += x_shift fracture . y_centroid += y_shift fracture . z_centroid += z_shift def generate_dfn_plotly ( self , add_centroid = False , size_color = False , fracture_color = 'blue' ): ''' Generates a plotly figure of the dfn object. Returns: A plotly figure ''' logger . info ( 'Generating plotly figure' ) fig = go . Figure () for fracture in tqdm ( self . dfn ): fracture_sides = fracture . get_side_points () if add_centroid : fig . add_trace ( go . Scatter3d ( x = [ fracture . x_centroid ], y = [ fracture . y_centroid ], z = [ fracture . z_centroid ], mode = 'markers' , marker = dict ( size = 3.5 , color = 'black' , symbol = 'circle' , opacity = 0.65 ) )) # Add color depending on the fracture size if size_color : A = 255 / ( self . max_size - self . min_size ) B = 255 - A * self . max_size value = int ( A * fracture . size + B ) color = f 'rgb( { value } , 0, 0)' else : color = fracture_color fig . add_trace ( go . Mesh3d ( x = fracture_sides [:, 0 ], y = fracture_sides [:, 1 ], z = fracture_sides [:, 2 ], color = color , opacity = 0.75 , )) return fig @property def max_size ( self ): \"\"\"Returns the maximum size of the dfn object.\"\"\" return max ([ fracture . size for fracture in self . dfn ]) @property def min_size ( self ): \"\"\"Returns the minimum size of the dfn object.\"\"\" return min ([ fracture . size for fracture in self . dfn ]) max_size property readonly Returns the maximum size of the dfn object. min_size property readonly Returns the minimum size of the dfn object. add_fracture ( self , x , y , z , dip = None , dip_dir = None , size = None , aperture = None ) Add individual fracture to the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def add_fracture ( self , x , y , z , dip = None , dip_dir = None , size = None , aperture = None ): \"\"\"Add individual fracture to the dfn object. \"\"\" self . dfn . append ( Fracture ( dip = dip , dip_dir = dip_dir , x = x , y = y , z = z , size = size , aperture = aperture )) clean_dfn ( self ) Removes dfn object Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def clean_dfn ( self ): \"\"\"Removes dfn object\"\"\" self . dfn = [] generate_dfn_plotly ( self , add_centroid = False , size_color = False , fracture_color = 'blue' ) Generates a plotly figure of the dfn object. Returns: A plotly figure Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def generate_dfn_plotly ( self , add_centroid = False , size_color = False , fracture_color = 'blue' ): ''' Generates a plotly figure of the dfn object. Returns: A plotly figure ''' logger . info ( 'Generating plotly figure' ) fig = go . Figure () for fracture in tqdm ( self . dfn ): fracture_sides = fracture . get_side_points () if add_centroid : fig . add_trace ( go . Scatter3d ( x = [ fracture . x_centroid ], y = [ fracture . y_centroid ], z = [ fracture . z_centroid ], mode = 'markers' , marker = dict ( size = 3.5 , color = 'black' , symbol = 'circle' , opacity = 0.65 ) )) # Add color depending on the fracture size if size_color : A = 255 / ( self . max_size - self . min_size ) B = 255 - A * self . max_size value = int ( A * fracture . size + B ) color = f 'rgb( { value } , 0, 0)' else : color = fracture_color fig . add_trace ( go . Mesh3d ( x = fracture_sides [:, 0 ], y = fracture_sides [:, 1 ], z = fracture_sides [:, 2 ], color = color , opacity = 0.75 , )) return fig load_fractures ( self , pd_df , dip = 'dip' , dip_dir = 'dip-direction' , x = 'position-x' , y = 'position-y' , z = 'position-z' , size = 'size' ) Loads the fractures from a pandas dataframe to the dfn object. Parameters: Name Type Description Default pd_df <module 'pandas' from '/opt/homebrew/Caskroom/miniforge/base/envs/pv_python39/lib/python3.9/site-packages/pandas/__init__.py'> pandas dataframe containing the fractures required Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def load_fractures ( self , pd_df : pd , dip = 'dip' , dip_dir = 'dip-direction' , x = 'position-x' , y = 'position-y' , z = 'position-z' , size = 'size' , ): \"\"\" Loads the fractures from a pandas dataframe to the dfn object. Args: pd_df: pandas dataframe containing the fractures Returns: \"\"\" for index , row in tqdm ( pd_df . iterrows ()): self . add_fracture ( dip = row [ dip ], dip_dir = row [ dip_dir ], x = row [ x ], y = row [ y ], z = row [ z ], size = row [ size ] ) shift_dfn ( self , x_shift = 0 , y_shift = 0 , z_shift = 0 ) Shifts the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def shift_dfn ( self , x_shift = 0 , y_shift = 0 , z_shift = 0 ): \"\"\"Shifts the dfn object.\"\"\" for fracture in self . dfn : fracture . x_centroid += x_shift fracture . y_centroid += y_shift fracture . z_centroid += z_shift summary ( self ) Prints a summary of the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def summary ( self ): \"\"\"Prints a summary of the dfn object.\"\"\" print ( tabulate ( [ [ 'Number of fractures' , len ( self . dfn )], [ 'Max size' , f \" { self . max_size : 1.2f } m\" ], [ 'Min size' , f \" { self . min_size : 1.2f } m\" ] ], headers = [ 'Parameter' , 'Value' ], tablefmt = 'grid' , numalign = 'center' , )) to_dfnworks ( self , filename = 'dfn.dat' , method = 'v2' ) Exports the dfn object to dfnworks format. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def to_dfnworks ( self , filename = 'dfn.dat' , method = 'v2' ): '''Exports the dfn object to dfnworks format.''' logger . info ( f 'Exporting dfn object to { filename } ' ) dfn_file = open ( filename , 'w' ) n_total_fractures = len ( self . dfn ) dfn_file . write ( f 'nPolygons: { n_total_fractures } \\n ' ) for fracture in tqdm ( self . dfn ): side_points = fracture . get_side_points ( method = method ) dfn_file . write ( f ' { len ( side_points ) } ' ) for point in side_points : dfn_file . write ( f ' {{ { point [ 0 ] } , { point [ 1 ] } , { point [ 2 ] } }} ' ) dfn_file . write ( ' \\n ' ) to_obj ( self , filename = 'dfn.obj' , method = 'v2' ) Exports the dfn object to stl format. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def to_obj ( self , filename = 'dfn.obj' , method = 'v2' ): '''Exports the dfn object to stl format.''' logger . info ( f 'Exporting dfn object to { filename } ' ) obj_file = open ( filename , 'w' ) obj_file . write ( '# Created by pydelling \\n ' ) obj_file . write ( 'o dfn \\n ' ) global_id = 1 for fracture in tqdm ( self . dfn ): obj_file . write ( fracture . to_obj ( global_id = global_id , method = method )) global_id += fracture . side_points visualize_dfn ( self , add_centroid = True , fracture_color = 'blue' , size_color = False ) Visualizes the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def visualize_dfn ( self , add_centroid = True , fracture_color = 'blue' , size_color = False ): \"\"\"Visualizes the dfn object.\"\"\" self . fig = self . generate_dfn_plotly ( add_centroid = add_centroid , fracture_color = fracture_color , size_color = size_color ) self . fig . show ()","title":"Dfn Preprocessor"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.max_size","text":"Returns the maximum size of the dfn object.","title":"max_size"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.min_size","text":"Returns the minimum size of the dfn object.","title":"min_size"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.add_fracture","text":"Add individual fracture to the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def add_fracture ( self , x , y , z , dip = None , dip_dir = None , size = None , aperture = None ): \"\"\"Add individual fracture to the dfn object. \"\"\" self . dfn . append ( Fracture ( dip = dip , dip_dir = dip_dir , x = x , y = y , z = z , size = size , aperture = aperture ))","title":"add_fracture()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.clean_dfn","text":"Removes dfn object Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def clean_dfn ( self ): \"\"\"Removes dfn object\"\"\" self . dfn = []","title":"clean_dfn()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.generate_dfn_plotly","text":"Generates a plotly figure of the dfn object. Returns: A plotly figure Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def generate_dfn_plotly ( self , add_centroid = False , size_color = False , fracture_color = 'blue' ): ''' Generates a plotly figure of the dfn object. Returns: A plotly figure ''' logger . info ( 'Generating plotly figure' ) fig = go . Figure () for fracture in tqdm ( self . dfn ): fracture_sides = fracture . get_side_points () if add_centroid : fig . add_trace ( go . Scatter3d ( x = [ fracture . x_centroid ], y = [ fracture . y_centroid ], z = [ fracture . z_centroid ], mode = 'markers' , marker = dict ( size = 3.5 , color = 'black' , symbol = 'circle' , opacity = 0.65 ) )) # Add color depending on the fracture size if size_color : A = 255 / ( self . max_size - self . min_size ) B = 255 - A * self . max_size value = int ( A * fracture . size + B ) color = f 'rgb( { value } , 0, 0)' else : color = fracture_color fig . add_trace ( go . Mesh3d ( x = fracture_sides [:, 0 ], y = fracture_sides [:, 1 ], z = fracture_sides [:, 2 ], color = color , opacity = 0.75 , )) return fig","title":"generate_dfn_plotly()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.load_fractures","text":"Loads the fractures from a pandas dataframe to the dfn object. Parameters: Name Type Description Default pd_df <module 'pandas' from '/opt/homebrew/Caskroom/miniforge/base/envs/pv_python39/lib/python3.9/site-packages/pandas/__init__.py'> pandas dataframe containing the fractures required Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def load_fractures ( self , pd_df : pd , dip = 'dip' , dip_dir = 'dip-direction' , x = 'position-x' , y = 'position-y' , z = 'position-z' , size = 'size' , ): \"\"\" Loads the fractures from a pandas dataframe to the dfn object. Args: pd_df: pandas dataframe containing the fractures Returns: \"\"\" for index , row in tqdm ( pd_df . iterrows ()): self . add_fracture ( dip = row [ dip ], dip_dir = row [ dip_dir ], x = row [ x ], y = row [ y ], z = row [ z ], size = row [ size ] )","title":"load_fractures()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.shift_dfn","text":"Shifts the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def shift_dfn ( self , x_shift = 0 , y_shift = 0 , z_shift = 0 ): \"\"\"Shifts the dfn object.\"\"\" for fracture in self . dfn : fracture . x_centroid += x_shift fracture . y_centroid += y_shift fracture . z_centroid += z_shift","title":"shift_dfn()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.summary","text":"Prints a summary of the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def summary ( self ): \"\"\"Prints a summary of the dfn object.\"\"\" print ( tabulate ( [ [ 'Number of fractures' , len ( self . dfn )], [ 'Max size' , f \" { self . max_size : 1.2f } m\" ], [ 'Min size' , f \" { self . min_size : 1.2f } m\" ] ], headers = [ 'Parameter' , 'Value' ], tablefmt = 'grid' , numalign = 'center' , ))","title":"summary()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.to_dfnworks","text":"Exports the dfn object to dfnworks format. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def to_dfnworks ( self , filename = 'dfn.dat' , method = 'v2' ): '''Exports the dfn object to dfnworks format.''' logger . info ( f 'Exporting dfn object to { filename } ' ) dfn_file = open ( filename , 'w' ) n_total_fractures = len ( self . dfn ) dfn_file . write ( f 'nPolygons: { n_total_fractures } \\n ' ) for fracture in tqdm ( self . dfn ): side_points = fracture . get_side_points ( method = method ) dfn_file . write ( f ' { len ( side_points ) } ' ) for point in side_points : dfn_file . write ( f ' {{ { point [ 0 ] } , { point [ 1 ] } , { point [ 2 ] } }} ' ) dfn_file . write ( ' \\n ' )","title":"to_dfnworks()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.to_obj","text":"Exports the dfn object to stl format. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def to_obj ( self , filename = 'dfn.obj' , method = 'v2' ): '''Exports the dfn object to stl format.''' logger . info ( f 'Exporting dfn object to { filename } ' ) obj_file = open ( filename , 'w' ) obj_file . write ( '# Created by pydelling \\n ' ) obj_file . write ( 'o dfn \\n ' ) global_id = 1 for fracture in tqdm ( self . dfn ): obj_file . write ( fracture . to_obj ( global_id = global_id , method = method )) global_id += fracture . side_points","title":"to_obj()"},{"location":"preprocessing/docs-preprocessing-dfn_preprocessor/#pydelling.preprocessing.dfn_preprocessor.DfnPreprocessor.DfnPreprocessor.visualize_dfn","text":"Visualizes the dfn object. Source code in pydelling/preprocessing/dfn_preprocessor/DfnPreprocessor.py def visualize_dfn ( self , add_centroid = True , fracture_color = 'blue' , size_color = False ): \"\"\"Visualizes the dfn object.\"\"\" self . fig = self . generate_dfn_plotly ( add_centroid = add_centroid , fracture_color = fracture_color , size_color = size_color ) self . fig . show ()","title":"visualize_dfn()"},{"location":"preprocessing/docs-preprocessing-dfn_upscaler/","text":"DfnUpscaler Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py class DfnUpscaler : def __init__ ( self , dfn : DfnPreprocessor , mesh : MeshPreprocessor , parallel = False , save_intersections = False ): self . dfn : DfnPreprocessor = dfn self . mesh : MeshPreprocessor = mesh logger . info ( 'The DFN and mesh objects have been set properly' ) self . all_intersected_points = [] self . save_intersections = save_intersections self . _intersect_dfn_with_mesh ( parallel = parallel ) def _intersect_dfn_with_mesh ( self , parallel = False ): \"\"\"Runs the DfnUpscaler\"\"\" logger . info ( 'Upscaling the DFN to the mesh' ) if not parallel : for fracture in tqdm ( self . dfn , desc = 'Intersecting fractures with mesh' , total = len ( self . dfn )): self . find_intersection_points_between_fracture_and_mesh ( fracture ) else : from joblib import Parallel , delayed import multiprocessing num_cores = multiprocessing . cpu_count () logger . info ( f 'Running using { num_cores } cores' ) Parallel ( n_jobs = num_cores )( delayed ( self . find_intersection_points_between_fracture_and_mesh )( fracture ) for fracture in tqdm ( self . dfn , desc = 'Intersecting fractures with mesh' , total = len ( self . dfn ))) if self . save_intersections : import csv with open ( 'intersections.csv' , 'w' ) as f : writer = csv . writer ( f ) writer . writerow ([ 'x' , 'y' , 'z' ]) for intersection in self . all_intersected_points : for point in intersection : writer . writerow ([ point . x , point . y , point . z ]) def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . mesh . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 elements_filtered = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 absolute_distance = np . abs ( fracture . distance_to_point ( element . centroid )) characteristic_length = np . power ( element . volume , 1 / 3 ) if absolute_distance > 2.0 * characteristic_length : elements_filtered += 1 continue intersection_points = element . intersect_with_fracture ( fracture ) if self . save_intersections : self . all_intersected_points . append ( intersection_points ) intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . mesh . find_intersection_stats [ 'intersection_points' ] . keys (): self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . mesh . find_intersection_stats [ 'total_intersections' ] += 1 self . mesh . is_intersected = True return intersection_points def _compute_fracture_volume_in_elements ( self ): # Compute volume of fractures in each element. #self.elements.total_fracture_volume = np.zeros([len(elements)]) for elem in tqdm ( self . mesh . elements , desc = \"Computing fracture volume fractions\" ): for fracture in elem . associated_fractures : fracture_dict = elem . associated_fractures [ fracture ] # Attribute of the element: portion of element occupied by fractures. elem . total_fracture_volume += fracture_dict [ 'volume' ] def upscale_mesh_porosity ( self , matrix_porosity = None ): # Compute upscaled porosity for each element. self . _compute_fracture_volume_in_elements () upscaled_porosity = {} for elem in tqdm ( self . mesh . elements , desc = \"Upscaling porosity\" ): upscaled_porosity [ elem . local_id ] = ( elem . total_fracture_volume / elem . volume ) # + ( # matrix_porosity[elem] * (1 - (elem.total_fracture_volume / elem.volume))) # if elem.total_fracture_volume > 0: # pass vtk_porosity = np . asarray ( self . mesh . elements ) for local_id in upscaled_porosity : vtk_porosity [ local_id ] = upscaled_porosity [ local_id ] self . mesh . cell_data [ 'upscaled_porosity' ] = [ vtk_porosity . tolist ()] self . upscaled_porosity = upscaled_porosity return upscaled_porosity def upscale_mesh_permeability ( self , matrix_permeability = None , rho = 1000 , g = 9.8 , mu = 8.9e-4 , mode = 'full_tensor' ): matrix_permeability = {} for elem in tqdm ( self . mesh . elements , desc = \"Creating permeability tensor for dummy anisotropic case\" ): matrix_permeability [ elem . local_id ] = np . ones ([ 3 , 3 ]) * 0.0 matrix_permeability_tensor = matrix_permeability # Check correct size of matrix_permeability. # matrix_permeability_tensor = np.zeros(len(self.elements)) # # if len(matrix_permeability) != len(self.elements): # print(\"Incorrect size for matrix permeability. Size of variable doesn't match number of elements in the mesh.\") # break # else: # for elem in tqdm(self.elements, desc=\"Check size of matrix permeability input\"): # if len(matrix_permeability[elem]) == 3: # if np.shape(matrix_permeability[elem]) == (3,3): # print(\"Matrix Permeability Tensor (3,3) for Anisotropic case.\") # continue # else: # print(\"Matrix Permeability Tensor must be an np.array([3,3]) for Anisotropic case.\") # elif len(matrix_permeability[elem]) == 1: # print(\"Matrix Permeability for Isotropic case.\") # matrix_permeability_tensor[elem] = np.zeros([3,3]) # matrix_permeability_tensor[elem][0,0] = matrix_permeability[elem] # continue # else: # print(\"Incorrect Matrix Permeability Tensor. Must be an np.array([3,3]) for use in Anisotropic case or a single float/int for use in Isotropic case.\") # continue # UPSCALED PERMEABILITY fracture_perm = {} upscaled_perm = {} # For each fracture, compute permeability tensor, # and add it to the elements intersected by the fracture. for elem in tqdm ( self . mesh . elements , desc = \"Upscaling permeability\" ): fracture_perm [ elem . local_id ] = np . zeros ([ 3 , 3 ]) upscaled_perm [ elem . local_id ] = np . zeros ([ 3 , 3 ]) for frac_name in elem . associated_fractures : frac_dict = elem . associated_fractures [ frac_name ] frac = frac_dict [ 'fracture' ] # n1 = math.cos(frac.dip * (math.pi / 180)) * math.sin(frac.dip_dir * (math.pi / 180)) # n2 = math.cos(frac.dip * (math.pi / 180)) * math.cos(frac.dip_dir * (math.pi / 180)) # n3 = -1 * math.sin(frac.dip * (math.pi / 180)) n1 = frac . unit_normal_vector [ 0 ] n2 = frac . unit_normal_vector [ 1 ] n3 = frac . unit_normal_vector [ 2 ] frac . perm = (( frac . aperture ** 2 ) * rho * g ) / ( 12 * mu ) if 'mode' == 'isotropy' : # Add fracture permeability, weighted by the area that the fracture occupies in the element. fracture_perm [ elem . local_id ][ 0 , 0 ] += frac . perm * frac_dict [ 'volume' ] / elem . volume #Kxx else : #'anisotropy' in 'mode': perm_tensor = np . zeros ([ 3 , 3 ]) #for i in range(1, 4): # for j in range(1, 4): # Compute tensor perm_tensor [ 0 , 0 ] = frac . perm * (( n2 ** 2 ) + ( n3 ** 2 )) perm_tensor [ 0 , 1 ] = frac . perm * ( - 1 ) * n1 * n2 perm_tensor [ 0 , 2 ] = frac . perm * ( - 1 ) * n1 * n3 perm_tensor [ 1 , 1 ] = frac . perm * (( n3 ** 2 ) + ( n1 ** 2 )) perm_tensor [ 1 , 2 ] = frac . perm * ( - 1 ) * n2 * n3 perm_tensor [ 2 , 2 ] = frac . perm * (( n1 ** 2 ) + ( n2 ** 2 )) if 'mode' == 'anisotropy_principals' : eigen_perm_tensor = np . diag ( np . linalg . eig ( perm_tensor )[ 0 ]) perm_tensor = eigen_perm_tensor # Add fracture permeability, weighted by the area that the fracture occupies in the element. fracture_perm [ elem . local_id ][ 0 , 0 ] += ( perm_tensor [ 0 , 0 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 0 , 1 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 0 , 2 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 1 , 0 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 1 , 1 ] += ( perm_tensor [ 1 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 1 , 2 ] += ( perm_tensor [ 1 , 2 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 2 , 0 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 2 , 1 ] += ( perm_tensor [ 1 , 2 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 2 , 2 ] += ( perm_tensor [ 2 , 2 ] * frac_dict [ 'volume' ] / elem . volume ) # Sum permeability contribution from fractures and from matrix. upscaled_perm [ elem . local_id ] = fracture_perm [ elem . local_id ] + matrix_permeability_tensor [ elem . local_id ] * ( 1 - ( elem . total_fracture_volume / elem . volume )) #Export values to VTK vtk_kxx = np . asarray ( self . mesh . elements ) vtk_kyy = np . asarray ( self . mesh . elements ) vtk_kzz = np . asarray ( self . mesh . elements ) vtk_kxy = np . asarray ( self . mesh . elements ) vtk_kxz = np . asarray ( self . mesh . elements ) vtk_kyz = np . asarray ( self . mesh . elements ) for local_id in upscaled_perm : vtk_kxx [ local_id ] = upscaled_perm [ local_id ][ 0 , 0 ] vtk_kyy [ local_id ] = upscaled_perm [ local_id ][ 1 , 1 ] vtk_kzz [ local_id ] = upscaled_perm [ local_id ][ 2 , 2 ] vtk_kxy [ local_id ] = upscaled_perm [ local_id ][ 0 , 1 ] vtk_kxz [ local_id ] = upscaled_perm [ local_id ][ 0 , 2 ] vtk_kyz [ local_id ] = upscaled_perm [ local_id ][ 1 , 2 ] self . mesh . cell_data [ 'Kxx' ] = [ vtk_kxx . tolist ()] self . mesh . cell_data [ 'Kyy' ] = [ vtk_kyy . tolist ()] self . mesh . cell_data [ 'Kzz' ] = [ vtk_kzz . tolist ()] self . mesh . cell_data [ 'Kxy' ] = [ vtk_kxy . tolist ()] self . mesh . cell_data [ 'Kxz' ] = [ vtk_kxz . tolist ()] self . mesh . cell_data [ 'Kyz' ] = [ vtk_kyz . tolist ()] self . upscaled_permeability = upscaled_perm return upscaled_perm def to_vtk ( self , filename ): \"\"\"Exports the mesh and the upscaled variables to VTK\"\"\" self . mesh . to_vtk ( filename ) def porosity_to_csv ( self , filename = './porosity.csv' ): \"\"\"Exports porosity values to csv Returns: \"\"\" import csv logger . info ( f \"Exporting porosity to { filename } \" ) with open ( filename , 'w' ) as csvfile : writer = csv . writer ( csvfile ) for element_id in self . upscaled_porosity : centroid = self . mesh . elements [ element_id ] . centroid porosity = self . upscaled_porosity [ element_id ] writer . writerow ([ centroid [ 0 ], centroid [ 1 ], centroid [ 2 ], porosity ]) def export_intersection_stats ( self , filename = 'intersection_stats.txt' ): # Export the run_stats dictionary to file assert self . mesh . is_intersected , 'The mesh has not been intersected yet.' import json with open ( 'run_stats.json' , 'w' ) as fp : json . dump ( self . mesh . find_intersection_stats , fp ) find_intersection_points_between_fracture_and_mesh ( self , fracture , export_stats = False ) Finds the intersection points between a fracture and the mesh Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . mesh . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 elements_filtered = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 absolute_distance = np . abs ( fracture . distance_to_point ( element . centroid )) characteristic_length = np . power ( element . volume , 1 / 3 ) if absolute_distance > 2.0 * characteristic_length : elements_filtered += 1 continue intersection_points = element . intersect_with_fracture ( fracture ) if self . save_intersections : self . all_intersected_points . append ( intersection_points ) intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . mesh . find_intersection_stats [ 'intersection_points' ] . keys (): self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . mesh . find_intersection_stats [ 'total_intersections' ] += 1 self . mesh . is_intersected = True return intersection_points porosity_to_csv ( self , filename = './porosity.csv' ) Exports porosity values to csv Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py def porosity_to_csv ( self , filename = './porosity.csv' ): \"\"\"Exports porosity values to csv Returns: \"\"\" import csv logger . info ( f \"Exporting porosity to { filename } \" ) with open ( filename , 'w' ) as csvfile : writer = csv . writer ( csvfile ) for element_id in self . upscaled_porosity : centroid = self . mesh . elements [ element_id ] . centroid porosity = self . upscaled_porosity [ element_id ] writer . writerow ([ centroid [ 0 ], centroid [ 1 ], centroid [ 2 ], porosity ]) to_vtk ( self , filename ) Exports the mesh and the upscaled variables to VTK Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py def to_vtk ( self , filename ): \"\"\"Exports the mesh and the upscaled variables to VTK\"\"\" self . mesh . to_vtk ( filename )","title":"Dfn Upscaler"},{"location":"preprocessing/docs-preprocessing-dfn_upscaler/#pydelling.preprocessing.dfn_preprocessor.DfnUpscaler.DfnUpscaler","text":"Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py class DfnUpscaler : def __init__ ( self , dfn : DfnPreprocessor , mesh : MeshPreprocessor , parallel = False , save_intersections = False ): self . dfn : DfnPreprocessor = dfn self . mesh : MeshPreprocessor = mesh logger . info ( 'The DFN and mesh objects have been set properly' ) self . all_intersected_points = [] self . save_intersections = save_intersections self . _intersect_dfn_with_mesh ( parallel = parallel ) def _intersect_dfn_with_mesh ( self , parallel = False ): \"\"\"Runs the DfnUpscaler\"\"\" logger . info ( 'Upscaling the DFN to the mesh' ) if not parallel : for fracture in tqdm ( self . dfn , desc = 'Intersecting fractures with mesh' , total = len ( self . dfn )): self . find_intersection_points_between_fracture_and_mesh ( fracture ) else : from joblib import Parallel , delayed import multiprocessing num_cores = multiprocessing . cpu_count () logger . info ( f 'Running using { num_cores } cores' ) Parallel ( n_jobs = num_cores )( delayed ( self . find_intersection_points_between_fracture_and_mesh )( fracture ) for fracture in tqdm ( self . dfn , desc = 'Intersecting fractures with mesh' , total = len ( self . dfn ))) if self . save_intersections : import csv with open ( 'intersections.csv' , 'w' ) as f : writer = csv . writer ( f ) writer . writerow ([ 'x' , 'y' , 'z' ]) for intersection in self . all_intersected_points : for point in intersection : writer . writerow ([ point . x , point . y , point . z ]) def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . mesh . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 elements_filtered = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 absolute_distance = np . abs ( fracture . distance_to_point ( element . centroid )) characteristic_length = np . power ( element . volume , 1 / 3 ) if absolute_distance > 2.0 * characteristic_length : elements_filtered += 1 continue intersection_points = element . intersect_with_fracture ( fracture ) if self . save_intersections : self . all_intersected_points . append ( intersection_points ) intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . mesh . find_intersection_stats [ 'intersection_points' ] . keys (): self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . mesh . find_intersection_stats [ 'total_intersections' ] += 1 self . mesh . is_intersected = True return intersection_points def _compute_fracture_volume_in_elements ( self ): # Compute volume of fractures in each element. #self.elements.total_fracture_volume = np.zeros([len(elements)]) for elem in tqdm ( self . mesh . elements , desc = \"Computing fracture volume fractions\" ): for fracture in elem . associated_fractures : fracture_dict = elem . associated_fractures [ fracture ] # Attribute of the element: portion of element occupied by fractures. elem . total_fracture_volume += fracture_dict [ 'volume' ] def upscale_mesh_porosity ( self , matrix_porosity = None ): # Compute upscaled porosity for each element. self . _compute_fracture_volume_in_elements () upscaled_porosity = {} for elem in tqdm ( self . mesh . elements , desc = \"Upscaling porosity\" ): upscaled_porosity [ elem . local_id ] = ( elem . total_fracture_volume / elem . volume ) # + ( # matrix_porosity[elem] * (1 - (elem.total_fracture_volume / elem.volume))) # if elem.total_fracture_volume > 0: # pass vtk_porosity = np . asarray ( self . mesh . elements ) for local_id in upscaled_porosity : vtk_porosity [ local_id ] = upscaled_porosity [ local_id ] self . mesh . cell_data [ 'upscaled_porosity' ] = [ vtk_porosity . tolist ()] self . upscaled_porosity = upscaled_porosity return upscaled_porosity def upscale_mesh_permeability ( self , matrix_permeability = None , rho = 1000 , g = 9.8 , mu = 8.9e-4 , mode = 'full_tensor' ): matrix_permeability = {} for elem in tqdm ( self . mesh . elements , desc = \"Creating permeability tensor for dummy anisotropic case\" ): matrix_permeability [ elem . local_id ] = np . ones ([ 3 , 3 ]) * 0.0 matrix_permeability_tensor = matrix_permeability # Check correct size of matrix_permeability. # matrix_permeability_tensor = np.zeros(len(self.elements)) # # if len(matrix_permeability) != len(self.elements): # print(\"Incorrect size for matrix permeability. Size of variable doesn't match number of elements in the mesh.\") # break # else: # for elem in tqdm(self.elements, desc=\"Check size of matrix permeability input\"): # if len(matrix_permeability[elem]) == 3: # if np.shape(matrix_permeability[elem]) == (3,3): # print(\"Matrix Permeability Tensor (3,3) for Anisotropic case.\") # continue # else: # print(\"Matrix Permeability Tensor must be an np.array([3,3]) for Anisotropic case.\") # elif len(matrix_permeability[elem]) == 1: # print(\"Matrix Permeability for Isotropic case.\") # matrix_permeability_tensor[elem] = np.zeros([3,3]) # matrix_permeability_tensor[elem][0,0] = matrix_permeability[elem] # continue # else: # print(\"Incorrect Matrix Permeability Tensor. Must be an np.array([3,3]) for use in Anisotropic case or a single float/int for use in Isotropic case.\") # continue # UPSCALED PERMEABILITY fracture_perm = {} upscaled_perm = {} # For each fracture, compute permeability tensor, # and add it to the elements intersected by the fracture. for elem in tqdm ( self . mesh . elements , desc = \"Upscaling permeability\" ): fracture_perm [ elem . local_id ] = np . zeros ([ 3 , 3 ]) upscaled_perm [ elem . local_id ] = np . zeros ([ 3 , 3 ]) for frac_name in elem . associated_fractures : frac_dict = elem . associated_fractures [ frac_name ] frac = frac_dict [ 'fracture' ] # n1 = math.cos(frac.dip * (math.pi / 180)) * math.sin(frac.dip_dir * (math.pi / 180)) # n2 = math.cos(frac.dip * (math.pi / 180)) * math.cos(frac.dip_dir * (math.pi / 180)) # n3 = -1 * math.sin(frac.dip * (math.pi / 180)) n1 = frac . unit_normal_vector [ 0 ] n2 = frac . unit_normal_vector [ 1 ] n3 = frac . unit_normal_vector [ 2 ] frac . perm = (( frac . aperture ** 2 ) * rho * g ) / ( 12 * mu ) if 'mode' == 'isotropy' : # Add fracture permeability, weighted by the area that the fracture occupies in the element. fracture_perm [ elem . local_id ][ 0 , 0 ] += frac . perm * frac_dict [ 'volume' ] / elem . volume #Kxx else : #'anisotropy' in 'mode': perm_tensor = np . zeros ([ 3 , 3 ]) #for i in range(1, 4): # for j in range(1, 4): # Compute tensor perm_tensor [ 0 , 0 ] = frac . perm * (( n2 ** 2 ) + ( n3 ** 2 )) perm_tensor [ 0 , 1 ] = frac . perm * ( - 1 ) * n1 * n2 perm_tensor [ 0 , 2 ] = frac . perm * ( - 1 ) * n1 * n3 perm_tensor [ 1 , 1 ] = frac . perm * (( n3 ** 2 ) + ( n1 ** 2 )) perm_tensor [ 1 , 2 ] = frac . perm * ( - 1 ) * n2 * n3 perm_tensor [ 2 , 2 ] = frac . perm * (( n1 ** 2 ) + ( n2 ** 2 )) if 'mode' == 'anisotropy_principals' : eigen_perm_tensor = np . diag ( np . linalg . eig ( perm_tensor )[ 0 ]) perm_tensor = eigen_perm_tensor # Add fracture permeability, weighted by the area that the fracture occupies in the element. fracture_perm [ elem . local_id ][ 0 , 0 ] += ( perm_tensor [ 0 , 0 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 0 , 1 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 0 , 2 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 1 , 0 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 1 , 1 ] += ( perm_tensor [ 1 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 1 , 2 ] += ( perm_tensor [ 1 , 2 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 2 , 0 ] += ( perm_tensor [ 0 , 1 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 2 , 1 ] += ( perm_tensor [ 1 , 2 ] * frac_dict [ 'volume' ] / elem . volume ) fracture_perm [ elem . local_id ][ 2 , 2 ] += ( perm_tensor [ 2 , 2 ] * frac_dict [ 'volume' ] / elem . volume ) # Sum permeability contribution from fractures and from matrix. upscaled_perm [ elem . local_id ] = fracture_perm [ elem . local_id ] + matrix_permeability_tensor [ elem . local_id ] * ( 1 - ( elem . total_fracture_volume / elem . volume )) #Export values to VTK vtk_kxx = np . asarray ( self . mesh . elements ) vtk_kyy = np . asarray ( self . mesh . elements ) vtk_kzz = np . asarray ( self . mesh . elements ) vtk_kxy = np . asarray ( self . mesh . elements ) vtk_kxz = np . asarray ( self . mesh . elements ) vtk_kyz = np . asarray ( self . mesh . elements ) for local_id in upscaled_perm : vtk_kxx [ local_id ] = upscaled_perm [ local_id ][ 0 , 0 ] vtk_kyy [ local_id ] = upscaled_perm [ local_id ][ 1 , 1 ] vtk_kzz [ local_id ] = upscaled_perm [ local_id ][ 2 , 2 ] vtk_kxy [ local_id ] = upscaled_perm [ local_id ][ 0 , 1 ] vtk_kxz [ local_id ] = upscaled_perm [ local_id ][ 0 , 2 ] vtk_kyz [ local_id ] = upscaled_perm [ local_id ][ 1 , 2 ] self . mesh . cell_data [ 'Kxx' ] = [ vtk_kxx . tolist ()] self . mesh . cell_data [ 'Kyy' ] = [ vtk_kyy . tolist ()] self . mesh . cell_data [ 'Kzz' ] = [ vtk_kzz . tolist ()] self . mesh . cell_data [ 'Kxy' ] = [ vtk_kxy . tolist ()] self . mesh . cell_data [ 'Kxz' ] = [ vtk_kxz . tolist ()] self . mesh . cell_data [ 'Kyz' ] = [ vtk_kyz . tolist ()] self . upscaled_permeability = upscaled_perm return upscaled_perm def to_vtk ( self , filename ): \"\"\"Exports the mesh and the upscaled variables to VTK\"\"\" self . mesh . to_vtk ( filename ) def porosity_to_csv ( self , filename = './porosity.csv' ): \"\"\"Exports porosity values to csv Returns: \"\"\" import csv logger . info ( f \"Exporting porosity to { filename } \" ) with open ( filename , 'w' ) as csvfile : writer = csv . writer ( csvfile ) for element_id in self . upscaled_porosity : centroid = self . mesh . elements [ element_id ] . centroid porosity = self . upscaled_porosity [ element_id ] writer . writerow ([ centroid [ 0 ], centroid [ 1 ], centroid [ 2 ], porosity ]) def export_intersection_stats ( self , filename = 'intersection_stats.txt' ): # Export the run_stats dictionary to file assert self . mesh . is_intersected , 'The mesh has not been intersected yet.' import json with open ( 'run_stats.json' , 'w' ) as fp : json . dump ( self . mesh . find_intersection_stats , fp )","title":"DfnUpscaler"},{"location":"preprocessing/docs-preprocessing-dfn_upscaler/#pydelling.preprocessing.dfn_preprocessor.DfnUpscaler.DfnUpscaler.find_intersection_points_between_fracture_and_mesh","text":"Finds the intersection points between a fracture and the mesh Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . mesh . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 elements_filtered = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 absolute_distance = np . abs ( fracture . distance_to_point ( element . centroid )) characteristic_length = np . power ( element . volume , 1 / 3 ) if absolute_distance > 2.0 * characteristic_length : elements_filtered += 1 continue intersection_points = element . intersect_with_fracture ( fracture ) if self . save_intersections : self . all_intersected_points . append ( intersection_points ) intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . mesh . find_intersection_stats [ 'intersection_points' ] . keys (): self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . mesh . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . mesh . find_intersection_stats [ 'total_intersections' ] += 1 self . mesh . is_intersected = True return intersection_points","title":"find_intersection_points_between_fracture_and_mesh()"},{"location":"preprocessing/docs-preprocessing-dfn_upscaler/#pydelling.preprocessing.dfn_preprocessor.DfnUpscaler.DfnUpscaler.porosity_to_csv","text":"Exports porosity values to csv Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py def porosity_to_csv ( self , filename = './porosity.csv' ): \"\"\"Exports porosity values to csv Returns: \"\"\" import csv logger . info ( f \"Exporting porosity to { filename } \" ) with open ( filename , 'w' ) as csvfile : writer = csv . writer ( csvfile ) for element_id in self . upscaled_porosity : centroid = self . mesh . elements [ element_id ] . centroid porosity = self . upscaled_porosity [ element_id ] writer . writerow ([ centroid [ 0 ], centroid [ 1 ], centroid [ 2 ], porosity ])","title":"porosity_to_csv()"},{"location":"preprocessing/docs-preprocessing-dfn_upscaler/#pydelling.preprocessing.dfn_preprocessor.DfnUpscaler.DfnUpscaler.to_vtk","text":"Exports the mesh and the upscaled variables to VTK Source code in pydelling/preprocessing/dfn_preprocessor/DfnUpscaler.py def to_vtk ( self , filename ): \"\"\"Exports the mesh and the upscaled variables to VTK\"\"\" self . mesh . to_vtk ( filename )","title":"to_vtk()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/","text":"Contains the logic to preprocess and work with a generic unstructured mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py class MeshPreprocessor ( object ): \"\"\"Contains the logic to preprocess and work with a generic unstructured mesh\"\"\" elements : List [ geometry . BaseElement ] coords : List [ np . ndarray ] centroids : List [ np . ndarray ] meshio_mesh : msh . Mesh = None kd_tree : KDTree point_data = {} cell_data = {} _coords = None _centroids = None is_intersected = False def __init__ ( self ): self . unordered_nodes = {} self . elements = [] self . find_intersection_stats = { 'total_intersections' : 0 , 'intersection_points' : { } } def add_element ( self , element : geometry . BaseElement ): self . elements . append ( element ) def add_tetrahedra ( self , node_ids : List [ int ] or np . ndarray , node_coords : List [ np . ndarray ]): \"\"\"Adds a tetrahedron to the mesh\"\"\" self . elements . append ( geometry . TetrahedraElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node def add_hexahedra ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a hexahedron to the mesh\"\"\" self . elements . append ( geometry . HexahedraElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node def add_wedge ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a wedge to the mesh\"\"\" self . elements . append ( geometry . WedgeElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node def add_triangular_prism ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a triangular prism to the mesh\"\"\" self . elements . append ( geometry . WedgeElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node @property def coords ( self ) -> np . ndarray : \"\"\"Orders the coords in the mesh\"\"\" if self . _coords is None : aux_nodes = np . ndarray ( shape = ( self . n_nodes , 3 )) for idx , node in self . unordered_nodes . items (): aux_nodes [ idx ] = node self . _coords = aux_nodes return self . _coords def add_quadrilateral ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): self . elements . append ( geometry . QuadrilateralFace ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node def add_triangle ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): self . elements . append ( geometry . TriangleFace ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node def add_node ( self , node : np . ndarray ): '''Explicitly adds a node (deprecated)''' self . coords . append ( node ) @property def n_nodes ( self ): \"\"\"Returns the number of node_ids in the mesh\"\"\" return len ( self . unordered_nodes ) @property def n_elements ( self ): \"\"\"Returns the number of elements in the mesh\"\"\" return len ( self . elements ) def convert_mesh_to_meshio ( self ): \"\"\"Converts the mesh into a meshio mesh Returns: meshio mesh \"\"\" elements_in_meshio = self . _create_meshio_dict ( self . elements ) self . meshio_mesh = msh . Mesh ( points = self . coords , cells = elements_in_meshio , cell_data = self . cell_data , point_data = self . point_data ) def to_vtk ( self , filename = 'mesh.vtk' ): \"\"\"Converts the mesh into vtk using meshio Args: filename: name of the output file \"\"\" logger . info ( f 'Converting mesh to vtk and exporting to { filename } ' ) self . convert_mesh_to_meshio () self . meshio_mesh . write ( filename ) def subset_to_vtk ( self , elements : List [ geometry . BaseAbstractMeshObject ], filename = 'subset.vtk' ): \"\"\"Converts a subset of the mesh into a vtk file Args: elements: list of element indices filename: name of the output file \"\"\" assert len ( elements ) > 0 , 'No elements to export' subset_mesh = self . _convert_subset_to_meshio ( elements ) subset_mesh . write ( filename ) def _convert_subset_to_meshio ( self , elements : List [ geometry . BaseAbstractMeshObject ]) -> msh . Mesh : \"\"\"Converts a subset of the mesh into a meshio mesh Args: elements: list of element indices Returns: meshio mesh \"\"\" elements_in_meshio = self . _create_meshio_dict ( elements ) return msh . Mesh ( points = self . coords , cells = elements_in_meshio , ) def _create_meshio_dict ( self , elements : List [ geometry . BaseAbstractMeshObject ]) -> Dict [ str , List [ List [ int ]]]: elements_in_meshio = {} for element in elements : if element . type == 'tetrahedra' : if not 'tetra' in elements_in_meshio . keys (): elements_in_meshio [ 'tetra' ] = [] elements_in_meshio [ 'tetra' ] . append ( element . nodes . tolist ()) elif element . type == 'hexahedra' : if not 'hexahedron' in elements_in_meshio . keys (): elements_in_meshio [ 'hexahedron' ] = [] elements_in_meshio [ 'hexahedron' ] . append ( element . nodes . tolist ()) elif element . type == 'wedge' : if not 'wedge' in elements_in_meshio . keys (): elements_in_meshio [ 'wedge' ] = [] elements_in_meshio [ 'wedge' ] . append ( element . nodes . tolist ()) elif element . type == 'triangle' : if not 'triangle' in elements_in_meshio . keys (): elements_in_meshio [ 'triangle' ] = [] elements_in_meshio [ 'triangle' ] . append ( element . nodes . tolist ()) elif element . type == 'quadrilateral' : if not 'quad' in elements_in_meshio . keys (): elements_in_meshio [ 'quad' ] = [] elements_in_meshio [ 'quad' ] . append ( element . nodes . tolist ()) return elements_in_meshio def nodes_to_csv ( self , filename = 'node_ids.csv' ): \"\"\"Exports the node_ids to CSV\"\"\" node_array = np . array ( self . coords ) np . savetxt ( filename , node_array , delimiter = ',' ) @property def centroids ( self ): \"\"\"Returns the centroids of the mesh\"\"\" if self . _centroids is None : centroids = [] for element in self . elements : centroids . append ( element . centroid ) self . _centroids = np . array ( centroids ) return self . _centroids def create_kd_tree ( self , kd_tree_config = None ): \"\"\" Create a KD-tree structure for the mesh. Args: kd_tree_config: A dictionary with the kd-tree configuration. \"\"\" if kd_tree_config is None : kd_tree_config = {} self . kd_tree = KDTree ( self . centroids , ** kd_tree_config ) def get_k_nearest_mesh_elements ( self , point , k = 15 , distance_upper_bound = None ): \"\"\" Get the nearest mesh elements to a point. Args: point: A point in 3D space. k: The number of nearest elements to return. Returns: A list of the nearest mesh elements. \"\"\" if not hasattr ( self , 'kd_tree' ): self . create_kd_tree () if distance_upper_bound : ids = self . kd_tree . query ( point , k = k , distance_upper_bound = distance_upper_bound )[ 1 ] else : ids = self . kd_tree . query ( point , k = k )[ 1 ] assert len ( ids ) != 0 , \"No elements found\" return [ self . elements [ i ] for i in ids ] def get_closest_mesh_elements ( self , point , distance = None ): \"\"\" Get the nearest mesh elements to a point inside a distance. Args: point: A point in 3D space. distance: The radius of the sphere. Returns: A list of the nearest mesh elements. \"\"\" if not hasattr ( self , 'kd_tree' ): self . create_kd_tree () ids = self . kd_tree . query_ball_point ( point , distance ) # assert len(ids) != 0, \"No elements found\" return [ self . elements [ i ] for i in ids ] def clear ( self ): \"\"\"Clears the mesh\"\"\" self . unordered_nodes = {} self . elements = [] @staticmethod def _intersect_fracture_with_element ( element , fracture ): \"\"\" Returns the intersection of a fracture with an element. Args: element: The element to intersect with. fracture: The fracture to intersect with. Returns: The intersection of the fracture and the element. \"\"\" return element . intersect ( fracture ) def _is_fracture_intersected ( self , fracture : Fracture , element : geometry . BaseElement ): \"\"\" Checks if a fracture is intersected by an element. Args: fracture: The fracture to intersect with. element: The element to intersect with. Returns: True if the fracture is intersected by the element, False otherwise. \"\"\" signs = [] bounding_box : List = fracture . get_bounding_box () for coord in element . coords : # Check if coord in bounding box if bounding_box [ 0 ] < coord [ 0 ] < bounding_box [ 1 ] and bounding_box [ 2 ] < coord [ 1 ] < bounding_box [ 3 ] and \\ bounding_box [ 4 ] < coord [ 2 ] < bounding_box [ 5 ]: distance_to_fracture = fracture . distance_to_point ( coord ) signs . append ( np . sign ( distance_to_fracture )) else : return False if not np . all ( np . array ( signs ) == signs [ 0 ]): return True def find_the_intersection_between_fracture_and_mesh ( self , fracture : Fracture ): \"\"\"Finds the intersection between a fracture and the mesh\"\"\" intersections = [] for element in self . elements : if self . _is_fracture_intersected ( fracture , element ): intersections . append ( element ) self . subset_to_vtk ( intersections , filename = 'intersections.vtk' ) def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 intersection_points = element . intersect_with_fracture ( fracture ) if len ( intersection_points ) >= 3 : intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . find_intersection_stats [ 'intersection_points' ] . keys (): self . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . find_intersection_stats [ 'total_intersections' ] += 1 self . is_intersected = True return intersection_points def export_intersection_stats ( self , filename = 'intersection_stats.txt' ): # Export the run_stats dictionary to file assert self . is_intersected , 'The mesh has not been intersected yet.' import json with open ( 'run_stats.json' , 'w' ) as fp : json . dump ( self . find_intersection_stats , fp ) @staticmethod def intersect_edge_plane ( edge : np . ndarray , edge_point : np . ndarray , plane : Fracture , ) -> np . ndarray or None : \"\"\"This method instersects a given edge with a plane. Args: edge: The edge to intersect. plane: The plane to intersect with. Returns: The intersection point of the edge and the plane. \"\"\" edge_dot = np . dot ( edge , plane . unit_normal_vector ) if edge_dot == 0 : return None else : t = - np . dot (( edge_point - plane . centroid ), plane . unit_normal_vector ) / edge_dot if t < 1.0 and t > 0.0 : point = edge_point + t * edge if plane . point_inside_bounding_box ( point ): return point else : return None centroids property readonly Returns the centroids of the mesh coords : ndarray property readonly Orders the coords in the mesh n_elements property readonly Returns the number of elements in the mesh n_nodes property readonly Returns the number of node_ids in the mesh add_hexahedra ( self , node_ids , node_coords ) Adds a hexahedron to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_hexahedra ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a hexahedron to the mesh\"\"\" self . elements . append ( geometry . HexahedraElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node add_node ( self , node ) Explicitly adds a node (deprecated) Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_node ( self , node : np . ndarray ): '''Explicitly adds a node (deprecated)''' self . coords . append ( node ) add_tetrahedra ( self , node_ids , node_coords ) Adds a tetrahedron to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_tetrahedra ( self , node_ids : List [ int ] or np . ndarray , node_coords : List [ np . ndarray ]): \"\"\"Adds a tetrahedron to the mesh\"\"\" self . elements . append ( geometry . TetrahedraElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node add_triangular_prism ( self , node_ids , node_coords ) Adds a triangular prism to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_triangular_prism ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a triangular prism to the mesh\"\"\" self . elements . append ( geometry . WedgeElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node add_wedge ( self , node_ids , node_coords ) Adds a wedge to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_wedge ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a wedge to the mesh\"\"\" self . elements . append ( geometry . WedgeElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node clear ( self ) Clears the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def clear ( self ): \"\"\"Clears the mesh\"\"\" self . unordered_nodes = {} self . elements = [] convert_mesh_to_meshio ( self ) Converts the mesh into a meshio mesh Returns: Type Description meshio mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def convert_mesh_to_meshio ( self ): \"\"\"Converts the mesh into a meshio mesh Returns: meshio mesh \"\"\" elements_in_meshio = self . _create_meshio_dict ( self . elements ) self . meshio_mesh = msh . Mesh ( points = self . coords , cells = elements_in_meshio , cell_data = self . cell_data , point_data = self . point_data ) create_kd_tree ( self , kd_tree_config = None ) Create a KD-tree structure for the mesh. Parameters: Name Type Description Default kd_tree_config A dictionary with the kd-tree configuration. None Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def create_kd_tree ( self , kd_tree_config = None ): \"\"\" Create a KD-tree structure for the mesh. Args: kd_tree_config: A dictionary with the kd-tree configuration. \"\"\" if kd_tree_config is None : kd_tree_config = {} self . kd_tree = KDTree ( self . centroids , ** kd_tree_config ) find_intersection_points_between_fracture_and_mesh ( self , fracture , export_stats = False ) Finds the intersection points between a fracture and the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 intersection_points = element . intersect_with_fracture ( fracture ) if len ( intersection_points ) >= 3 : intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . find_intersection_stats [ 'intersection_points' ] . keys (): self . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . find_intersection_stats [ 'total_intersections' ] += 1 self . is_intersected = True return intersection_points find_the_intersection_between_fracture_and_mesh ( self , fracture ) Finds the intersection between a fracture and the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def find_the_intersection_between_fracture_and_mesh ( self , fracture : Fracture ): \"\"\"Finds the intersection between a fracture and the mesh\"\"\" intersections = [] for element in self . elements : if self . _is_fracture_intersected ( fracture , element ): intersections . append ( element ) self . subset_to_vtk ( intersections , filename = 'intersections.vtk' ) get_closest_mesh_elements ( self , point , distance = None ) Get the nearest mesh elements to a point inside a distance. Parameters: Name Type Description Default point A point in 3D space. required distance The radius of the sphere. None Returns: Type Description A list of the nearest mesh elements. Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def get_closest_mesh_elements ( self , point , distance = None ): \"\"\" Get the nearest mesh elements to a point inside a distance. Args: point: A point in 3D space. distance: The radius of the sphere. Returns: A list of the nearest mesh elements. \"\"\" if not hasattr ( self , 'kd_tree' ): self . create_kd_tree () ids = self . kd_tree . query_ball_point ( point , distance ) # assert len(ids) != 0, \"No elements found\" return [ self . elements [ i ] for i in ids ] get_k_nearest_mesh_elements ( self , point , k = 15 , distance_upper_bound = None ) Get the nearest mesh elements to a point. Parameters: Name Type Description Default point A point in 3D space. required k The number of nearest elements to return. 15 Returns: Type Description A list of the nearest mesh elements. Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def get_k_nearest_mesh_elements ( self , point , k = 15 , distance_upper_bound = None ): \"\"\" Get the nearest mesh elements to a point. Args: point: A point in 3D space. k: The number of nearest elements to return. Returns: A list of the nearest mesh elements. \"\"\" if not hasattr ( self , 'kd_tree' ): self . create_kd_tree () if distance_upper_bound : ids = self . kd_tree . query ( point , k = k , distance_upper_bound = distance_upper_bound )[ 1 ] else : ids = self . kd_tree . query ( point , k = k )[ 1 ] assert len ( ids ) != 0 , \"No elements found\" return [ self . elements [ i ] for i in ids ] intersect_edge_plane ( edge , edge_point , plane ) staticmethod This method instersects a given edge with a plane. Parameters: Name Type Description Default edge ndarray The edge to intersect. required plane Fracture The plane to intersect with. required Returns: Type Description ndarray The intersection point of the edge and the plane. Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py @staticmethod def intersect_edge_plane ( edge : np . ndarray , edge_point : np . ndarray , plane : Fracture , ) -> np . ndarray or None : \"\"\"This method instersects a given edge with a plane. Args: edge: The edge to intersect. plane: The plane to intersect with. Returns: The intersection point of the edge and the plane. \"\"\" edge_dot = np . dot ( edge , plane . unit_normal_vector ) if edge_dot == 0 : return None else : t = - np . dot (( edge_point - plane . centroid ), plane . unit_normal_vector ) / edge_dot if t < 1.0 and t > 0.0 : point = edge_point + t * edge if plane . point_inside_bounding_box ( point ): return point else : return None nodes_to_csv ( self , filename = 'node_ids.csv' ) Exports the node_ids to CSV Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def nodes_to_csv ( self , filename = 'node_ids.csv' ): \"\"\"Exports the node_ids to CSV\"\"\" node_array = np . array ( self . coords ) np . savetxt ( filename , node_array , delimiter = ',' ) subset_to_vtk ( self , elements , filename = 'subset.vtk' ) Converts a subset of the mesh into a vtk file Parameters: Name Type Description Default elements List[pydelling.preprocessing.mesh_preprocessor.geometry.BaseAbstractMeshObject.BaseAbstractMeshObject] list of element indices required filename name of the output file 'subset.vtk' Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def subset_to_vtk ( self , elements : List [ geometry . BaseAbstractMeshObject ], filename = 'subset.vtk' ): \"\"\"Converts a subset of the mesh into a vtk file Args: elements: list of element indices filename: name of the output file \"\"\" assert len ( elements ) > 0 , 'No elements to export' subset_mesh = self . _convert_subset_to_meshio ( elements ) subset_mesh . write ( filename ) to_vtk ( self , filename = 'mesh.vtk' ) Converts the mesh into vtk using meshio Parameters: Name Type Description Default filename name of the output file 'mesh.vtk' Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def to_vtk ( self , filename = 'mesh.vtk' ): \"\"\"Converts the mesh into vtk using meshio Args: filename: name of the output file \"\"\" logger . info ( f 'Converting mesh to vtk and exporting to { filename } ' ) self . convert_mesh_to_meshio () self . meshio_mesh . write ( filename )","title":"Mesh preprocessor"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.centroids","text":"Returns the centroids of the mesh","title":"centroids"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.coords","text":"Orders the coords in the mesh","title":"coords"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.n_elements","text":"Returns the number of elements in the mesh","title":"n_elements"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.n_nodes","text":"Returns the number of node_ids in the mesh","title":"n_nodes"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.add_hexahedra","text":"Adds a hexahedron to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_hexahedra ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a hexahedron to the mesh\"\"\" self . elements . append ( geometry . HexahedraElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node","title":"add_hexahedra()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.add_node","text":"Explicitly adds a node (deprecated) Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_node ( self , node : np . ndarray ): '''Explicitly adds a node (deprecated)''' self . coords . append ( node )","title":"add_node()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.add_tetrahedra","text":"Adds a tetrahedron to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_tetrahedra ( self , node_ids : List [ int ] or np . ndarray , node_coords : List [ np . ndarray ]): \"\"\"Adds a tetrahedron to the mesh\"\"\" self . elements . append ( geometry . TetrahedraElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node","title":"add_tetrahedra()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.add_triangular_prism","text":"Adds a triangular prism to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_triangular_prism ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a triangular prism to the mesh\"\"\" self . elements . append ( geometry . WedgeElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node","title":"add_triangular_prism()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.add_wedge","text":"Adds a wedge to the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def add_wedge ( self , node_ids : List [ int ], node_coords : List [ np . ndarray ]): \"\"\"Adds a wedge to the mesh\"\"\" self . elements . append ( geometry . WedgeElement ( node_ids = node_ids , node_coords = node_coords )) for idx , node in enumerate ( node_coords ): self . unordered_nodes [ node_ids [ idx ]] = node","title":"add_wedge()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.clear","text":"Clears the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def clear ( self ): \"\"\"Clears the mesh\"\"\" self . unordered_nodes = {} self . elements = []","title":"clear()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.convert_mesh_to_meshio","text":"Converts the mesh into a meshio mesh Returns: Type Description meshio mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def convert_mesh_to_meshio ( self ): \"\"\"Converts the mesh into a meshio mesh Returns: meshio mesh \"\"\" elements_in_meshio = self . _create_meshio_dict ( self . elements ) self . meshio_mesh = msh . Mesh ( points = self . coords , cells = elements_in_meshio , cell_data = self . cell_data , point_data = self . point_data )","title":"convert_mesh_to_meshio()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.create_kd_tree","text":"Create a KD-tree structure for the mesh. Parameters: Name Type Description Default kd_tree_config A dictionary with the kd-tree configuration. None Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def create_kd_tree ( self , kd_tree_config = None ): \"\"\" Create a KD-tree structure for the mesh. Args: kd_tree_config: A dictionary with the kd-tree configuration. \"\"\" if kd_tree_config is None : kd_tree_config = {} self . kd_tree = KDTree ( self . centroids , ** kd_tree_config )","title":"create_kd_tree()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.find_intersection_points_between_fracture_and_mesh","text":"Finds the intersection points between a fracture and the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def find_intersection_points_between_fracture_and_mesh ( self , fracture : Fracture , export_stats = False ): \"\"\"Finds the intersection points between a fracture and the mesh\"\"\" intersection_points = [] kd_tree_filtered_elements = self . get_closest_mesh_elements ( fracture . centroid , distance = fracture . size ) counter = 0 for element in kd_tree_filtered_elements : element : geometry . BaseElement counter += 1 intersection_points = element . intersect_with_fracture ( fracture ) if len ( intersection_points ) >= 3 : intersection_area = compute_polygon_area ( intersection_points ) fracture . intersection_dictionary [ element . local_id ] = intersection_area element . associated_fractures [ fracture . local_id ] = { 'area' : intersection_area , 'volume' : intersection_area * fracture . aperture , 'fracture' : fracture , } n_intersections = len ( intersection_points ) if not n_intersections in self . find_intersection_stats [ 'intersection_points' ] . keys (): self . find_intersection_stats [ 'intersection_points' ][ n_intersections ] = 0 self . find_intersection_stats [ 'intersection_points' ][ n_intersections ] += 1 self . find_intersection_stats [ 'total_intersections' ] += 1 self . is_intersected = True return intersection_points","title":"find_intersection_points_between_fracture_and_mesh()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.find_the_intersection_between_fracture_and_mesh","text":"Finds the intersection between a fracture and the mesh Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def find_the_intersection_between_fracture_and_mesh ( self , fracture : Fracture ): \"\"\"Finds the intersection between a fracture and the mesh\"\"\" intersections = [] for element in self . elements : if self . _is_fracture_intersected ( fracture , element ): intersections . append ( element ) self . subset_to_vtk ( intersections , filename = 'intersections.vtk' )","title":"find_the_intersection_between_fracture_and_mesh()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.get_closest_mesh_elements","text":"Get the nearest mesh elements to a point inside a distance. Parameters: Name Type Description Default point A point in 3D space. required distance The radius of the sphere. None Returns: Type Description A list of the nearest mesh elements. Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def get_closest_mesh_elements ( self , point , distance = None ): \"\"\" Get the nearest mesh elements to a point inside a distance. Args: point: A point in 3D space. distance: The radius of the sphere. Returns: A list of the nearest mesh elements. \"\"\" if not hasattr ( self , 'kd_tree' ): self . create_kd_tree () ids = self . kd_tree . query_ball_point ( point , distance ) # assert len(ids) != 0, \"No elements found\" return [ self . elements [ i ] for i in ids ]","title":"get_closest_mesh_elements()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.get_k_nearest_mesh_elements","text":"Get the nearest mesh elements to a point. Parameters: Name Type Description Default point A point in 3D space. required k The number of nearest elements to return. 15 Returns: Type Description A list of the nearest mesh elements. Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def get_k_nearest_mesh_elements ( self , point , k = 15 , distance_upper_bound = None ): \"\"\" Get the nearest mesh elements to a point. Args: point: A point in 3D space. k: The number of nearest elements to return. Returns: A list of the nearest mesh elements. \"\"\" if not hasattr ( self , 'kd_tree' ): self . create_kd_tree () if distance_upper_bound : ids = self . kd_tree . query ( point , k = k , distance_upper_bound = distance_upper_bound )[ 1 ] else : ids = self . kd_tree . query ( point , k = k )[ 1 ] assert len ( ids ) != 0 , \"No elements found\" return [ self . elements [ i ] for i in ids ]","title":"get_k_nearest_mesh_elements()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.intersect_edge_plane","text":"This method instersects a given edge with a plane. Parameters: Name Type Description Default edge ndarray The edge to intersect. required plane Fracture The plane to intersect with. required Returns: Type Description ndarray The intersection point of the edge and the plane. Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py @staticmethod def intersect_edge_plane ( edge : np . ndarray , edge_point : np . ndarray , plane : Fracture , ) -> np . ndarray or None : \"\"\"This method instersects a given edge with a plane. Args: edge: The edge to intersect. plane: The plane to intersect with. Returns: The intersection point of the edge and the plane. \"\"\" edge_dot = np . dot ( edge , plane . unit_normal_vector ) if edge_dot == 0 : return None else : t = - np . dot (( edge_point - plane . centroid ), plane . unit_normal_vector ) / edge_dot if t < 1.0 and t > 0.0 : point = edge_point + t * edge if plane . point_inside_bounding_box ( point ): return point else : return None","title":"intersect_edge_plane()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.nodes_to_csv","text":"Exports the node_ids to CSV Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def nodes_to_csv ( self , filename = 'node_ids.csv' ): \"\"\"Exports the node_ids to CSV\"\"\" node_array = np . array ( self . coords ) np . savetxt ( filename , node_array , delimiter = ',' )","title":"nodes_to_csv()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.subset_to_vtk","text":"Converts a subset of the mesh into a vtk file Parameters: Name Type Description Default elements List[pydelling.preprocessing.mesh_preprocessor.geometry.BaseAbstractMeshObject.BaseAbstractMeshObject] list of element indices required filename name of the output file 'subset.vtk' Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def subset_to_vtk ( self , elements : List [ geometry . BaseAbstractMeshObject ], filename = 'subset.vtk' ): \"\"\"Converts a subset of the mesh into a vtk file Args: elements: list of element indices filename: name of the output file \"\"\" assert len ( elements ) > 0 , 'No elements to export' subset_mesh = self . _convert_subset_to_meshio ( elements ) subset_mesh . write ( filename )","title":"subset_to_vtk()"},{"location":"preprocessing/docs-preprocessing-mesh_preprocessor/#pydelling.preprocessing.mesh_preprocessor.MeshPreprocessor.MeshPreprocessor.to_vtk","text":"Converts the mesh into vtk using meshio Parameters: Name Type Description Default filename name of the output file 'mesh.vtk' Source code in pydelling/preprocessing/mesh_preprocessor/MeshPreprocessor.py def to_vtk ( self , filename = 'mesh.vtk' ): \"\"\"Converts the mesh into vtk using meshio Args: filename: name of the output file \"\"\" logger . info ( f 'Converting mesh to vtk and exporting to { filename } ' ) self . convert_mesh_to_meshio () self . meshio_mesh . write ( filename )","title":"to_vtk()"},{"location":"readers/docs-readers-filters-centroid/","text":"Centroid file reader CentroidReader ( BaseReader ) This class reads a data file described by a set of centroids Source code in pydelling/readers/CentroidReader.py class CentroidReader ( BaseReader ): \"\"\"This class reads a data file described by a set of centroids\"\"\" def __init__ ( self , filename , var_pos = 3 , var_name = \"var\" , var_type = np . float32 , centroid_pos = ( 0 , 3 ), header = False , separator = None ): self . var_pos = var_pos self . var = None self . var_name = var_name self . var_type = var_type self . centroid_pos = centroid_pos self . header = header self . split_key = separator if self . var_pos : logger . info ( f \"Reading data using centroids in positions [ { self . centroid_pos [ 0 ] } , { self . centroid_pos [ 1 ] - 1 } ] and data in position { self . var_pos } \" ) else : logger . info ( f \"Reading data using centroids in positions [ { self . centroid_pos [ 0 ] } , { self . centroid_pos [ 1 ] - 1 } ]\" ) super () . __init__ ( filename , var_pos = var_pos , var_name = var_name , var_type = var_type , centroid_pos = centroid_pos , header = header ) def read_file ( self , opened_file ): \"\"\" Reads the data and stores it inside the class \"\"\" logger . info ( f \"Reading centroid file from { self . filename } \" ) temp_centroid = [] temp_id = [] for line in opened_file . readlines (): if self . split_key : data_row = line . split ( self . split_key ) else : data_row = line . split () temp_centroid . append ( data_row [ self . centroid_pos [ 0 ]: self . centroid_pos [ 1 ] + 1 ]) if self . var_pos : temp_id . append ([ data_row [ self . var_pos ]]) self . data = np . array ( temp_centroid , dtype = np . float32 ) if self . var_pos : self . var = np . array ( temp_id , dtype = self . var_type ) def read_header ( self ): \"\"\" TODO: Add the header reader of the centroid file Reads the header of the file :return: \"\"\" pass def get_data ( self , as_dataframe = False ) -> pd . DataFrame : \"\"\" Outputs the data :return: np.ndarray object containing centroid information and variable output \"\"\" if as_dataframe : if self . var_pos : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' , f \" { self . var_name } \" ]) else : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' ]) else : return self . data def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info [ \"reader\" ] = { \"n_cells\" : self . data . shape [ 0 ], \"filename\" : self . filename , \"var_name\" : self . var_name , \"var_position\" : self . var_pos } def to_csv ( self , output_file , delimiter = \",\" ): \"\"\" Writes the data into a csv file :param output_file: :return: \"\"\" logger . info ( f \"Starting dump into { output_file } \" ) np . savetxt ( output_file , self . get_data (), delimiter = delimiter ) logger . info ( f \"The data has been properly exported to the { output_file } file\" ) def shift ( self , direction = np . array ([ 0.0 , 0.0 , 0.0 ])): \"\"\"Shifts the data coordinates on the given direction Args: direction: direction vector \"\"\" if type ( direction ) is list : direction = np . array ( direction ) self . data [:, 0 : 3 ] += direction build_info ( self ) Generates a dictionary containing the basic info of the read data :return: Source code in pydelling/readers/CentroidReader.py def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info [ \"reader\" ] = { \"n_cells\" : self . data . shape [ 0 ], \"filename\" : self . filename , \"var_name\" : self . var_name , \"var_position\" : self . var_pos } get_data ( self , as_dataframe = False ) Outputs the data :return: np.ndarray object containing centroid information and variable output Source code in pydelling/readers/CentroidReader.py def get_data ( self , as_dataframe = False ) -> pd . DataFrame : \"\"\" Outputs the data :return: np.ndarray object containing centroid information and variable output \"\"\" if as_dataframe : if self . var_pos : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' , f \" { self . var_name } \" ]) else : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' ]) else : return self . data read_file ( self , opened_file ) Reads the data and stores it inside the class Source code in pydelling/readers/CentroidReader.py def read_file ( self , opened_file ): \"\"\" Reads the data and stores it inside the class \"\"\" logger . info ( f \"Reading centroid file from { self . filename } \" ) temp_centroid = [] temp_id = [] for line in opened_file . readlines (): if self . split_key : data_row = line . split ( self . split_key ) else : data_row = line . split () temp_centroid . append ( data_row [ self . centroid_pos [ 0 ]: self . centroid_pos [ 1 ] + 1 ]) if self . var_pos : temp_id . append ([ data_row [ self . var_pos ]]) self . data = np . array ( temp_centroid , dtype = np . float32 ) if self . var_pos : self . var = np . array ( temp_id , dtype = self . var_type ) read_header ( self ) TODO: Add the header reader of the centroid file Reads the header of the file :return: Source code in pydelling/readers/CentroidReader.py def read_header ( self ): \"\"\" TODO: Add the header reader of the centroid file Reads the header of the file :return: \"\"\" pass shift ( self , direction = array ([ 0. , 0. , 0. ])) Shifts the data coordinates on the given direction Parameters: Name Type Description Default direction direction vector array([0., 0., 0.]) Source code in pydelling/readers/CentroidReader.py def shift ( self , direction = np . array ([ 0.0 , 0.0 , 0.0 ])): \"\"\"Shifts the data coordinates on the given direction Args: direction: direction vector \"\"\" if type ( direction ) is list : direction = np . array ( direction ) self . data [:, 0 : 3 ] += direction to_csv ( self , output_file , delimiter = ',' ) Writes the data into a csv file :param output_file: :return: Source code in pydelling/readers/CentroidReader.py def to_csv ( self , output_file , delimiter = \",\" ): \"\"\" Writes the data into a csv file :param output_file: :return: \"\"\" logger . info ( f \"Starting dump into { output_file } \" ) np . savetxt ( output_file , self . get_data (), delimiter = delimiter ) logger . info ( f \"The data has been properly exported to the { output_file } file\" )","title":"Docs readers filters centroid"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader","text":"This class reads a data file described by a set of centroids Source code in pydelling/readers/CentroidReader.py class CentroidReader ( BaseReader ): \"\"\"This class reads a data file described by a set of centroids\"\"\" def __init__ ( self , filename , var_pos = 3 , var_name = \"var\" , var_type = np . float32 , centroid_pos = ( 0 , 3 ), header = False , separator = None ): self . var_pos = var_pos self . var = None self . var_name = var_name self . var_type = var_type self . centroid_pos = centroid_pos self . header = header self . split_key = separator if self . var_pos : logger . info ( f \"Reading data using centroids in positions [ { self . centroid_pos [ 0 ] } , { self . centroid_pos [ 1 ] - 1 } ] and data in position { self . var_pos } \" ) else : logger . info ( f \"Reading data using centroids in positions [ { self . centroid_pos [ 0 ] } , { self . centroid_pos [ 1 ] - 1 } ]\" ) super () . __init__ ( filename , var_pos = var_pos , var_name = var_name , var_type = var_type , centroid_pos = centroid_pos , header = header ) def read_file ( self , opened_file ): \"\"\" Reads the data and stores it inside the class \"\"\" logger . info ( f \"Reading centroid file from { self . filename } \" ) temp_centroid = [] temp_id = [] for line in opened_file . readlines (): if self . split_key : data_row = line . split ( self . split_key ) else : data_row = line . split () temp_centroid . append ( data_row [ self . centroid_pos [ 0 ]: self . centroid_pos [ 1 ] + 1 ]) if self . var_pos : temp_id . append ([ data_row [ self . var_pos ]]) self . data = np . array ( temp_centroid , dtype = np . float32 ) if self . var_pos : self . var = np . array ( temp_id , dtype = self . var_type ) def read_header ( self ): \"\"\" TODO: Add the header reader of the centroid file Reads the header of the file :return: \"\"\" pass def get_data ( self , as_dataframe = False ) -> pd . DataFrame : \"\"\" Outputs the data :return: np.ndarray object containing centroid information and variable output \"\"\" if as_dataframe : if self . var_pos : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' , f \" { self . var_name } \" ]) else : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' ]) else : return self . data def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info [ \"reader\" ] = { \"n_cells\" : self . data . shape [ 0 ], \"filename\" : self . filename , \"var_name\" : self . var_name , \"var_position\" : self . var_pos } def to_csv ( self , output_file , delimiter = \",\" ): \"\"\" Writes the data into a csv file :param output_file: :return: \"\"\" logger . info ( f \"Starting dump into { output_file } \" ) np . savetxt ( output_file , self . get_data (), delimiter = delimiter ) logger . info ( f \"The data has been properly exported to the { output_file } file\" ) def shift ( self , direction = np . array ([ 0.0 , 0.0 , 0.0 ])): \"\"\"Shifts the data coordinates on the given direction Args: direction: direction vector \"\"\" if type ( direction ) is list : direction = np . array ( direction ) self . data [:, 0 : 3 ] += direction","title":"CentroidReader"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader.build_info","text":"Generates a dictionary containing the basic info of the read data :return: Source code in pydelling/readers/CentroidReader.py def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info [ \"reader\" ] = { \"n_cells\" : self . data . shape [ 0 ], \"filename\" : self . filename , \"var_name\" : self . var_name , \"var_position\" : self . var_pos }","title":"build_info()"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader.get_data","text":"Outputs the data :return: np.ndarray object containing centroid information and variable output Source code in pydelling/readers/CentroidReader.py def get_data ( self , as_dataframe = False ) -> pd . DataFrame : \"\"\" Outputs the data :return: np.ndarray object containing centroid information and variable output \"\"\" if as_dataframe : if self . var_pos : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' , f \" { self . var_name } \" ]) else : return pd . DataFrame ( self . data , columns = [ 'x' , 'y' , 'z' ]) else : return self . data","title":"get_data()"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader.read_file","text":"Reads the data and stores it inside the class Source code in pydelling/readers/CentroidReader.py def read_file ( self , opened_file ): \"\"\" Reads the data and stores it inside the class \"\"\" logger . info ( f \"Reading centroid file from { self . filename } \" ) temp_centroid = [] temp_id = [] for line in opened_file . readlines (): if self . split_key : data_row = line . split ( self . split_key ) else : data_row = line . split () temp_centroid . append ( data_row [ self . centroid_pos [ 0 ]: self . centroid_pos [ 1 ] + 1 ]) if self . var_pos : temp_id . append ([ data_row [ self . var_pos ]]) self . data = np . array ( temp_centroid , dtype = np . float32 ) if self . var_pos : self . var = np . array ( temp_id , dtype = self . var_type )","title":"read_file()"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader.read_header","text":"TODO: Add the header reader of the centroid file Reads the header of the file :return: Source code in pydelling/readers/CentroidReader.py def read_header ( self ): \"\"\" TODO: Add the header reader of the centroid file Reads the header of the file :return: \"\"\" pass","title":"read_header()"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader.shift","text":"Shifts the data coordinates on the given direction Parameters: Name Type Description Default direction direction vector array([0., 0., 0.]) Source code in pydelling/readers/CentroidReader.py def shift ( self , direction = np . array ([ 0.0 , 0.0 , 0.0 ])): \"\"\"Shifts the data coordinates on the given direction Args: direction: direction vector \"\"\" if type ( direction ) is list : direction = np . array ( direction ) self . data [:, 0 : 3 ] += direction","title":"shift()"},{"location":"readers/docs-readers-filters-centroid/#pydelling.readers.CentroidReader.CentroidReader.to_csv","text":"Writes the data into a csv file :param output_file: :return: Source code in pydelling/readers/CentroidReader.py def to_csv ( self , output_file , delimiter = \",\" ): \"\"\" Writes the data into a csv file :param output_file: :return: \"\"\" logger . info ( f \"Starting dump into { output_file } \" ) np . savetxt ( output_file , self . get_data (), delimiter = delimiter ) logger . info ( f \"The data has been properly exported to the { output_file } file\" )","title":"to_csv()"},{"location":"readers/docs-readers-filters-connectflow/","text":"Base interface for a reader class ConnectFlowReader ( BaseReader ) Source code in pydelling/readers/ConnectFlowReader.py class ConnectFlowReader ( BaseReader ): def __init__ ( self , filename = None ): self . filename = Path ( filename ) if filename else Path ( config . open_foam_reader . filename ) logger . info ( f \"Reading ConnectFlow mesh file from { self . filename } \" ) super () . __init__ ( filename = self . filename ) def open_file ( self , filename ): filename_string = str ( filename ) header = getline ( filename_string , 1 ) . split () self . n_nodes = int ( header [ 1 ]) self . n_elements = int ( header [ 3 ]) self . n_mat = int ( header [ 5 ]) with open ( filename , \"r\" ) as opened_file : _nodes = [ line . rstrip () . split () for line in opened_file . readlines ()[ 2 : 2 + self . n_nodes - 1 ]] self . _mesh_nodes = pd . DataFrame ( np . array ( _nodes ) . astype ( np . float ), columns = [ \"index\" , \"x\" , \"y\" , \"z\" ]) self . _mesh_nodes = self . mesh_nodes . set_index ( \"index\" ) self . build_info () @property def mesh_nodes ( self ) -> pd . DataFrame : assert hasattr ( self , \"_mesh_nodes\" ), \"Mesh has not been properly assigned\" return self . _mesh_nodes def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 ) def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" min_x = self . _mesh_nodes [ \"x\" ] . min () max_x = self . _mesh_nodes [ \"x\" ] . max () min_y = self . _mesh_nodes [ \"y\" ] . min () max_y = self . _mesh_nodes [ \"y\" ] . max () min_z = self . _mesh_nodes [ \"z\" ] . min () max_z = self . _mesh_nodes [ \"z\" ] . max () self . info = { \"bounds\" : { \"x\" : [ min_x , max_x ], \"y\" : [ min_y , max_y ], \"z\" : [ min_z , max_z ], } } self . info . update ({ \"span\" : { \"x\" : self . info [ \"bounds\" ][ \"x\" ][ 1 ] - self . info [ \"bounds\" ][ \"x\" ][ 0 ], \"y\" : self . info [ \"bounds\" ][ \"y\" ][ 1 ] - self . info [ \"bounds\" ][ \"y\" ][ 0 ], \"z\" : self . info [ \"bounds\" ][ \"z\" ][ 1 ] - self . info [ \"bounds\" ][ \"z\" ][ 0 ], } }) def get_bounds ( self ): \"\"\" Returns the x, y and z axis bounds Returns: A list containing the bounds \"\"\" return self . info [ \"bounds\" ] def get_span ( self ): \"\"\" Returns the x, y and z axis span Returns: A list containing the span \"\"\" return self . info [ \"span\" ] build_info ( self ) Generates a dictionary containing the basic info of the read data :return: Source code in pydelling/readers/ConnectFlowReader.py def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" min_x = self . _mesh_nodes [ \"x\" ] . min () max_x = self . _mesh_nodes [ \"x\" ] . max () min_y = self . _mesh_nodes [ \"y\" ] . min () max_y = self . _mesh_nodes [ \"y\" ] . max () min_z = self . _mesh_nodes [ \"z\" ] . min () max_z = self . _mesh_nodes [ \"z\" ] . max () self . info = { \"bounds\" : { \"x\" : [ min_x , max_x ], \"y\" : [ min_y , max_y ], \"z\" : [ min_z , max_z ], } } self . info . update ({ \"span\" : { \"x\" : self . info [ \"bounds\" ][ \"x\" ][ 1 ] - self . info [ \"bounds\" ][ \"x\" ][ 0 ], \"y\" : self . info [ \"bounds\" ][ \"y\" ][ 1 ] - self . info [ \"bounds\" ][ \"y\" ][ 0 ], \"z\" : self . info [ \"bounds\" ][ \"z\" ][ 1 ] - self . info [ \"bounds\" ][ \"z\" ][ 0 ], } }) get_bounds ( self ) Returns the x, y and z axis bounds Returns: Type Description A list containing the bounds Source code in pydelling/readers/ConnectFlowReader.py def get_bounds ( self ): \"\"\" Returns the x, y and z axis bounds Returns: A list containing the bounds \"\"\" return self . info [ \"bounds\" ] get_data ( self ) Outputs the read data :return: Source code in pydelling/readers/ConnectFlowReader.py def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 ) get_span ( self ) Returns the x, y and z axis span Returns: Type Description A list containing the span Source code in pydelling/readers/ConnectFlowReader.py def get_span ( self ): \"\"\" Returns the x, y and z axis span Returns: A list containing the span \"\"\" return self . info [ \"span\" ]","title":"Docs readers filters connectflow"},{"location":"readers/docs-readers-filters-connectflow/#pydelling.readers.ConnectFlowReader.ConnectFlowReader","text":"Source code in pydelling/readers/ConnectFlowReader.py class ConnectFlowReader ( BaseReader ): def __init__ ( self , filename = None ): self . filename = Path ( filename ) if filename else Path ( config . open_foam_reader . filename ) logger . info ( f \"Reading ConnectFlow mesh file from { self . filename } \" ) super () . __init__ ( filename = self . filename ) def open_file ( self , filename ): filename_string = str ( filename ) header = getline ( filename_string , 1 ) . split () self . n_nodes = int ( header [ 1 ]) self . n_elements = int ( header [ 3 ]) self . n_mat = int ( header [ 5 ]) with open ( filename , \"r\" ) as opened_file : _nodes = [ line . rstrip () . split () for line in opened_file . readlines ()[ 2 : 2 + self . n_nodes - 1 ]] self . _mesh_nodes = pd . DataFrame ( np . array ( _nodes ) . astype ( np . float ), columns = [ \"index\" , \"x\" , \"y\" , \"z\" ]) self . _mesh_nodes = self . mesh_nodes . set_index ( \"index\" ) self . build_info () @property def mesh_nodes ( self ) -> pd . DataFrame : assert hasattr ( self , \"_mesh_nodes\" ), \"Mesh has not been properly assigned\" return self . _mesh_nodes def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 ) def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" min_x = self . _mesh_nodes [ \"x\" ] . min () max_x = self . _mesh_nodes [ \"x\" ] . max () min_y = self . _mesh_nodes [ \"y\" ] . min () max_y = self . _mesh_nodes [ \"y\" ] . max () min_z = self . _mesh_nodes [ \"z\" ] . min () max_z = self . _mesh_nodes [ \"z\" ] . max () self . info = { \"bounds\" : { \"x\" : [ min_x , max_x ], \"y\" : [ min_y , max_y ], \"z\" : [ min_z , max_z ], } } self . info . update ({ \"span\" : { \"x\" : self . info [ \"bounds\" ][ \"x\" ][ 1 ] - self . info [ \"bounds\" ][ \"x\" ][ 0 ], \"y\" : self . info [ \"bounds\" ][ \"y\" ][ 1 ] - self . info [ \"bounds\" ][ \"y\" ][ 0 ], \"z\" : self . info [ \"bounds\" ][ \"z\" ][ 1 ] - self . info [ \"bounds\" ][ \"z\" ][ 0 ], } }) def get_bounds ( self ): \"\"\" Returns the x, y and z axis bounds Returns: A list containing the bounds \"\"\" return self . info [ \"bounds\" ] def get_span ( self ): \"\"\" Returns the x, y and z axis span Returns: A list containing the span \"\"\" return self . info [ \"span\" ]","title":"ConnectFlowReader"},{"location":"readers/docs-readers-filters-connectflow/#pydelling.readers.ConnectFlowReader.ConnectFlowReader.build_info","text":"Generates a dictionary containing the basic info of the read data :return: Source code in pydelling/readers/ConnectFlowReader.py def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" min_x = self . _mesh_nodes [ \"x\" ] . min () max_x = self . _mesh_nodes [ \"x\" ] . max () min_y = self . _mesh_nodes [ \"y\" ] . min () max_y = self . _mesh_nodes [ \"y\" ] . max () min_z = self . _mesh_nodes [ \"z\" ] . min () max_z = self . _mesh_nodes [ \"z\" ] . max () self . info = { \"bounds\" : { \"x\" : [ min_x , max_x ], \"y\" : [ min_y , max_y ], \"z\" : [ min_z , max_z ], } } self . info . update ({ \"span\" : { \"x\" : self . info [ \"bounds\" ][ \"x\" ][ 1 ] - self . info [ \"bounds\" ][ \"x\" ][ 0 ], \"y\" : self . info [ \"bounds\" ][ \"y\" ][ 1 ] - self . info [ \"bounds\" ][ \"y\" ][ 0 ], \"z\" : self . info [ \"bounds\" ][ \"z\" ][ 1 ] - self . info [ \"bounds\" ][ \"z\" ][ 0 ], } })","title":"build_info()"},{"location":"readers/docs-readers-filters-connectflow/#pydelling.readers.ConnectFlowReader.ConnectFlowReader.get_bounds","text":"Returns the x, y and z axis bounds Returns: Type Description A list containing the bounds Source code in pydelling/readers/ConnectFlowReader.py def get_bounds ( self ): \"\"\" Returns the x, y and z axis bounds Returns: A list containing the bounds \"\"\" return self . info [ \"bounds\" ]","title":"get_bounds()"},{"location":"readers/docs-readers-filters-connectflow/#pydelling.readers.ConnectFlowReader.ConnectFlowReader.get_data","text":"Outputs the read data :return: Source code in pydelling/readers/ConnectFlowReader.py def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 )","title":"get_data()"},{"location":"readers/docs-readers-filters-connectflow/#pydelling.readers.ConnectFlowReader.ConnectFlowReader.get_span","text":"Returns the x, y and z axis span Returns: Type Description A list containing the span Source code in pydelling/readers/ConnectFlowReader.py def get_span ( self ): \"\"\" Returns the x, y and z axis span Returns: A list containing the span \"\"\" return self . info [ \"span\" ]","title":"get_span()"},{"location":"readers/docs-readers-filters-fem/","text":"","title":"Docs readers filters fem"},{"location":"readers/docs-readers-filters-openfoam/","text":"Base interface for a reader class OpenFoamReader ( BaseReader ) Source code in pydelling/readers/OpenFoamReader.py class OpenFoamReader ( BaseReader ): def __init__ ( self , filename = None ): self . filename = Path ( filename ) if filename else Path ( config . open_foam_reader . filename ) logger . info ( f \"Reading OpenFOAM mesh file from { self . filename } \" ) super () . __init__ ( filename = self . filename ) def open_file ( self , filename ): self . mesh = Ofpp . FoamMesh ( self . filename ) @property def cell_centers ( self ) -> np . array : if not config . globals . is_cell_centers_read : try : self . mesh . read_cell_centres ( str ( self . filename / \"0/C\" )) logger . info ( f \"Reading cell center locations from { self . filename / '0/C' } \" ) config . globals . is_cell_centers_read = True except : logger . info ( f \"Reading cell center locations from { self . filename / 'constant/C' } \" ) self . mesh . read_cell_centres ( str ( self . filename / \"constant/C\" )) config . globals . is_cell_centers_read = True return self . mesh . cell_centres @property def cell_volumes ( self ) -> np . array : if not config . globals . is_cell_volumes_read : try : self . mesh . read_cell_volumes ( str ( self . filename / \"0/V\" )) logger . info ( f \"Reading cell volume locations from { self . filename / '0/V' } \" ) config . globals . is_cell_volumes_read = True except : logger . info ( f \"Reading cell volume locations from { self . filename / 'constant/V' } \" ) self . mesh . read_cell_volumes ( str ( self . filename / \"constant/V\" )) config . globals . is_cell_volumes_read = True return self . mesh . cell_volumes def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 ) def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info = {} build_info ( self ) Generates a dictionary containing the basic info of the read data :return: Source code in pydelling/readers/OpenFoamReader.py def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info = {} get_data ( self ) Outputs the read data :return: Source code in pydelling/readers/OpenFoamReader.py def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 )","title":"Docs readers filters openfoam"},{"location":"readers/docs-readers-filters-openfoam/#pydelling.readers.OpenFoamReader.OpenFoamReader","text":"Source code in pydelling/readers/OpenFoamReader.py class OpenFoamReader ( BaseReader ): def __init__ ( self , filename = None ): self . filename = Path ( filename ) if filename else Path ( config . open_foam_reader . filename ) logger . info ( f \"Reading OpenFOAM mesh file from { self . filename } \" ) super () . __init__ ( filename = self . filename ) def open_file ( self , filename ): self . mesh = Ofpp . FoamMesh ( self . filename ) @property def cell_centers ( self ) -> np . array : if not config . globals . is_cell_centers_read : try : self . mesh . read_cell_centres ( str ( self . filename / \"0/C\" )) logger . info ( f \"Reading cell center locations from { self . filename / '0/C' } \" ) config . globals . is_cell_centers_read = True except : logger . info ( f \"Reading cell center locations from { self . filename / 'constant/C' } \" ) self . mesh . read_cell_centres ( str ( self . filename / \"constant/C\" )) config . globals . is_cell_centers_read = True return self . mesh . cell_centres @property def cell_volumes ( self ) -> np . array : if not config . globals . is_cell_volumes_read : try : self . mesh . read_cell_volumes ( str ( self . filename / \"0/V\" )) logger . info ( f \"Reading cell volume locations from { self . filename / '0/V' } \" ) config . globals . is_cell_volumes_read = True except : logger . info ( f \"Reading cell volume locations from { self . filename / 'constant/V' } \" ) self . mesh . read_cell_volumes ( str ( self . filename / \"constant/V\" )) config . globals . is_cell_volumes_read = True return self . mesh . cell_volumes def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 ) def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info = {}","title":"OpenFoamReader"},{"location":"readers/docs-readers-filters-openfoam/#pydelling.readers.OpenFoamReader.OpenFoamReader.build_info","text":"Generates a dictionary containing the basic info of the read data :return: Source code in pydelling/readers/OpenFoamReader.py def build_info ( self ): \"\"\" Generates a dictionary containing the basic info of the read data :return: \"\"\" self . info = {}","title":"build_info()"},{"location":"readers/docs-readers-filters-openfoam/#pydelling.readers.OpenFoamReader.OpenFoamReader.get_data","text":"Outputs the read data :return: Source code in pydelling/readers/OpenFoamReader.py def get_data ( self ) -> np . ndarray : \"\"\" Outputs the read data :return: \"\"\" return np . array ( 0 )","title":"get_data()"},{"location":"readers/docs-readers-filters-pflotran_observation_point/","text":"Base interface for a reader class PflotranObservationPointReader ( BaseReader ) Source code in pydelling/readers/PflotranObservationPointReader.py class PflotranObservationPointReader ( BaseReader ): observation_point : np . ndarray observation_boundary : str observation_node : int variables : dict def __init__ ( self , filename = None ): self . filename = Path ( filename ) if filename else Path ( config . pflotran_reader . filename ) logger . info ( f \"Reading PFLOTRAN observation point results file from { self . filename } \" ) super () . __init__ ( filename = self . filename ) self . results = self . data . copy () # self.results = {} # for time in self.time_keys: # self.results[time] = PflotranResults(time=time, data=self.data[self.time_keys[time]]) # self.variables = list(self.results[self.time_values[0]].variable_keys) def open_file ( self , filename ): self . data : pd . DataFrame = pd . read_csv ( self . filename , skiprows = 1 , header = None , delim_whitespace = True ) header = pd . read_csv ( self . filename , nrows = 0 ) . columns . tolist () self . data . columns = header # Rename time column time_column : str = self . data . columns . to_list ()[ 0 ] self . data . rename ( columns = { time_column : time_column . strip () . strip ( '\"' )}, inplace = True ) # Get observation point information temp_column_name : str = self . data . columns [ 1 ] temp_column_name = temp_column_name . replace ( '(' , '' ) . replace ( ')' , '' ) splitted_column_name = temp_column_name . split ( ' ' ) self . observation_point = np . array ([ splitted_column_name [ - 3 ], splitted_column_name [ - 2 ], splitted_column_name [ - 3 ]], ) . astype ( float ) self . observation_node = int ( splitted_column_name [ - 4 ]) self . observation_boundary = splitted_column_name [ - 5 ] # Get output column names self . variables = {} for column in self . data . columns : if 'Time' in column : continue test_column_name : str = column test_column_name_split = test_column_name . split ( '-' )[ 1 ] . split () variable_str = [] flag_list = [ 'east' , 'west' , 'north' , 'south' , 'top' , 'bottom' ] for piece in test_column_name_split : if piece in flag_list : break else : variable_str . append ( piece ) variable_str = ' ' . join ( variable_str ) self . variables [ variable_str ] = column self . data . rename ( columns = { column : variable_str }, inplace = True ) @property def mineral_names ( self ): temp_keys = [ key for key in self . variables if 'VF' in key ] return temp_keys @property def total_species_names ( self ): temp_keys = [ key for key in self . variables if 'Total' in key ] return temp_keys @property def free_species_names ( self ): temp_keys = [ key for key in self . variables if 'Free' in key ] return temp_keys def plot_variable ( self , variable ) -> plt . Axes : logger . info ( f 'Creating lineplot of { variable } ' ) plt . clf () lineplot : plt . Axes = sns . lineplot ( x = self . time_series , y = self . results [ variable ]) lineplot . set_label ( f ' { variable } ' ) return lineplot def to_csv ( self , filename = 'postprocess/results.csv' , variables = None ) -> pd . DataFrame : self . create_postprocess_dict () logger . info ( f 'Exporting results to csv' ) if variables : plot_results : pd . DataFrame = self . results [ variables ] plot_results . to_csv ( filename ) else : self . results . to_csv ( filename , index = False ) # print(self.variables) def get_mineral_vf_key ( self , mineral ): \"\"\" Returns the correct key of the mineral volume fraction name Args: mineral: mineral name Returns: mineral volume fraction key \"\"\" return f \" { mineral } _VF [m^3 mnrl_m^3 bulk]\" def get_mineral_rate_key ( self , mineral ): \"\"\" Returns the correct key of the mineral rate name Args: mineral: mineral name Returns: mineral rate key \"\"\" return f \" { mineral } _Rate [mol_m^3_sec]\" def get_mineral_si_key ( self , mineral ): \"\"\" Returns the correct key of the mineral si name Args: mineral: mineral name Returns: mineral si key \"\"\" return f \" { mineral } _SI\" def get_primary_species_key ( self , species ): \"\"\" Returns the correct key of the given species name Args: species: specie name Returns: specie key \"\"\" return f \"Total_ { species } \" @property def time_series ( self ): return self . results . iloc [:, 0 ] get_mineral_rate_key ( self , mineral ) Returns the correct key of the mineral rate name Parameters: Name Type Description Default mineral mineral name required Returns: Type Description mineral rate key Source code in pydelling/readers/PflotranObservationPointReader.py def get_mineral_rate_key ( self , mineral ): \"\"\" Returns the correct key of the mineral rate name Args: mineral: mineral name Returns: mineral rate key \"\"\" return f \" { mineral } _Rate [mol_m^3_sec]\" get_mineral_si_key ( self , mineral ) Returns the correct key of the mineral si name Parameters: Name Type Description Default mineral mineral name required Returns: Type Description mineral si key Source code in pydelling/readers/PflotranObservationPointReader.py def get_mineral_si_key ( self , mineral ): \"\"\" Returns the correct key of the mineral si name Args: mineral: mineral name Returns: mineral si key \"\"\" return f \" { mineral } _SI\" get_mineral_vf_key ( self , mineral ) Returns the correct key of the mineral volume fraction name Parameters: Name Type Description Default mineral mineral name required Returns: Type Description mineral volume fraction key Source code in pydelling/readers/PflotranObservationPointReader.py def get_mineral_vf_key ( self , mineral ): \"\"\" Returns the correct key of the mineral volume fraction name Args: mineral: mineral name Returns: mineral volume fraction key \"\"\" return f \" { mineral } _VF [m^3 mnrl_m^3 bulk]\" get_primary_species_key ( self , species ) Returns the correct key of the given species name Parameters: Name Type Description Default species specie name required Returns: Type Description specie key Source code in pydelling/readers/PflotranObservationPointReader.py def get_primary_species_key ( self , species ): \"\"\" Returns the correct key of the given species name Args: species: specie name Returns: specie key \"\"\" return f \"Total_ { species } \"","title":"Docs readers filters pflotran observation point"},{"location":"readers/docs-readers-filters-pflotran_observation_point/#pydelling.readers.PflotranObservationPointReader.PflotranObservationPointReader","text":"Source code in pydelling/readers/PflotranObservationPointReader.py class PflotranObservationPointReader ( BaseReader ): observation_point : np . ndarray observation_boundary : str observation_node : int variables : dict def __init__ ( self , filename = None ): self . filename = Path ( filename ) if filename else Path ( config . pflotran_reader . filename ) logger . info ( f \"Reading PFLOTRAN observation point results file from { self . filename } \" ) super () . __init__ ( filename = self . filename ) self . results = self . data . copy () # self.results = {} # for time in self.time_keys: # self.results[time] = PflotranResults(time=time, data=self.data[self.time_keys[time]]) # self.variables = list(self.results[self.time_values[0]].variable_keys) def open_file ( self , filename ): self . data : pd . DataFrame = pd . read_csv ( self . filename , skiprows = 1 , header = None , delim_whitespace = True ) header = pd . read_csv ( self . filename , nrows = 0 ) . columns . tolist () self . data . columns = header # Rename time column time_column : str = self . data . columns . to_list ()[ 0 ] self . data . rename ( columns = { time_column : time_column . strip () . strip ( '\"' )}, inplace = True ) # Get observation point information temp_column_name : str = self . data . columns [ 1 ] temp_column_name = temp_column_name . replace ( '(' , '' ) . replace ( ')' , '' ) splitted_column_name = temp_column_name . split ( ' ' ) self . observation_point = np . array ([ splitted_column_name [ - 3 ], splitted_column_name [ - 2 ], splitted_column_name [ - 3 ]], ) . astype ( float ) self . observation_node = int ( splitted_column_name [ - 4 ]) self . observation_boundary = splitted_column_name [ - 5 ] # Get output column names self . variables = {} for column in self . data . columns : if 'Time' in column : continue test_column_name : str = column test_column_name_split = test_column_name . split ( '-' )[ 1 ] . split () variable_str = [] flag_list = [ 'east' , 'west' , 'north' , 'south' , 'top' , 'bottom' ] for piece in test_column_name_split : if piece in flag_list : break else : variable_str . append ( piece ) variable_str = ' ' . join ( variable_str ) self . variables [ variable_str ] = column self . data . rename ( columns = { column : variable_str }, inplace = True ) @property def mineral_names ( self ): temp_keys = [ key for key in self . variables if 'VF' in key ] return temp_keys @property def total_species_names ( self ): temp_keys = [ key for key in self . variables if 'Total' in key ] return temp_keys @property def free_species_names ( self ): temp_keys = [ key for key in self . variables if 'Free' in key ] return temp_keys def plot_variable ( self , variable ) -> plt . Axes : logger . info ( f 'Creating lineplot of { variable } ' ) plt . clf () lineplot : plt . Axes = sns . lineplot ( x = self . time_series , y = self . results [ variable ]) lineplot . set_label ( f ' { variable } ' ) return lineplot def to_csv ( self , filename = 'postprocess/results.csv' , variables = None ) -> pd . DataFrame : self . create_postprocess_dict () logger . info ( f 'Exporting results to csv' ) if variables : plot_results : pd . DataFrame = self . results [ variables ] plot_results . to_csv ( filename ) else : self . results . to_csv ( filename , index = False ) # print(self.variables) def get_mineral_vf_key ( self , mineral ): \"\"\" Returns the correct key of the mineral volume fraction name Args: mineral: mineral name Returns: mineral volume fraction key \"\"\" return f \" { mineral } _VF [m^3 mnrl_m^3 bulk]\" def get_mineral_rate_key ( self , mineral ): \"\"\" Returns the correct key of the mineral rate name Args: mineral: mineral name Returns: mineral rate key \"\"\" return f \" { mineral } _Rate [mol_m^3_sec]\" def get_mineral_si_key ( self , mineral ): \"\"\" Returns the correct key of the mineral si name Args: mineral: mineral name Returns: mineral si key \"\"\" return f \" { mineral } _SI\" def get_primary_species_key ( self , species ): \"\"\" Returns the correct key of the given species name Args: species: specie name Returns: specie key \"\"\" return f \"Total_ { species } \" @property def time_series ( self ): return self . results . iloc [:, 0 ]","title":"PflotranObservationPointReader"},{"location":"readers/docs-readers-filters-pflotran_observation_point/#pydelling.readers.PflotranObservationPointReader.PflotranObservationPointReader.get_mineral_rate_key","text":"Returns the correct key of the mineral rate name Parameters: Name Type Description Default mineral mineral name required Returns: Type Description mineral rate key Source code in pydelling/readers/PflotranObservationPointReader.py def get_mineral_rate_key ( self , mineral ): \"\"\" Returns the correct key of the mineral rate name Args: mineral: mineral name Returns: mineral rate key \"\"\" return f \" { mineral } _Rate [mol_m^3_sec]\"","title":"get_mineral_rate_key()"},{"location":"readers/docs-readers-filters-pflotran_observation_point/#pydelling.readers.PflotranObservationPointReader.PflotranObservationPointReader.get_mineral_si_key","text":"Returns the correct key of the mineral si name Parameters: Name Type Description Default mineral mineral name required Returns: Type Description mineral si key Source code in pydelling/readers/PflotranObservationPointReader.py def get_mineral_si_key ( self , mineral ): \"\"\" Returns the correct key of the mineral si name Args: mineral: mineral name Returns: mineral si key \"\"\" return f \" { mineral } _SI\"","title":"get_mineral_si_key()"},{"location":"readers/docs-readers-filters-pflotran_observation_point/#pydelling.readers.PflotranObservationPointReader.PflotranObservationPointReader.get_mineral_vf_key","text":"Returns the correct key of the mineral volume fraction name Parameters: Name Type Description Default mineral mineral name required Returns: Type Description mineral volume fraction key Source code in pydelling/readers/PflotranObservationPointReader.py def get_mineral_vf_key ( self , mineral ): \"\"\" Returns the correct key of the mineral volume fraction name Args: mineral: mineral name Returns: mineral volume fraction key \"\"\" return f \" { mineral } _VF [m^3 mnrl_m^3 bulk]\"","title":"get_mineral_vf_key()"},{"location":"readers/docs-readers-filters-pflotran_observation_point/#pydelling.readers.PflotranObservationPointReader.PflotranObservationPointReader.get_primary_species_key","text":"Returns the correct key of the given species name Parameters: Name Type Description Default species specie name required Returns: Type Description specie key Source code in pydelling/readers/PflotranObservationPointReader.py def get_primary_species_key ( self , species ): \"\"\" Returns the correct key of the given species name Args: species: specie name Returns: specie key \"\"\" return f \"Total_ { species } \"","title":"get_primary_species_key()"},{"location":"utilities/docs-utilities-general/","text":"Plane Plane ( BasePrimitive ) Source code in pydelling/utils/geometry/Plane.py class Plane ( BasePrimitive ): def __init__ ( self , point : Point or List or np . ndarray , normal : List or Vector or np . ndarray ): self . p = Point ( point ) self . n = Vector ( normal ) def __repr__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def __str__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" ) def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True intersect ( self , primitive ) Returns the intersection of this plane with the given primitive Source code in pydelling/utils/geometry/Plane.py def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" ) is_parallel ( self , plane ) Returns True if this plane is parallel to the given plane Source code in pydelling/utils/geometry/Plane.py def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True Point Point ( ndarray ) Source code in pydelling/utils/geometry/Point.py class Point ( np . ndarray ): def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ())) def __repr__ ( self ): return f \"Point( { self } )\" @property def x ( self ): return self [ 0 ] @property def y ( self ): return self [ 1 ] @property def z ( self ): return self [ 2 ] __new__ ( cls , input_array ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Point.py def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj distance ( self , p ) Computes euclidean distance between two points Source code in pydelling/utils/geometry/Point.py def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ())) Vector Vector ( ndarray , BasePrimitive ) Source code in pydelling/utils/geometry/Vector.py class Vector ( np . ndarray , BasePrimitive ): coords : np . ndarray def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" ) def __repr__ ( self ): return f \"Vector( { self } )\" __new__ ( cls , v = None , p1 = None , p2 = None , * args , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Vector.py def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" ) intersections intersect_plane_line ( plane , line ) Performs the intersection of this plane with the given line Source code in pydelling/utils/geometry/intersections.py def intersect_plane_line ( plane : Plane , line : Line ): \"\"\"Performs the intersection of this plane with the given line\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - line . p ) dot_n_v = np . dot ( plane . n , line . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v return Point ( line . p + lambda_ * line . direction_vector ) intersect_plane_plane ( plane_1 , plane_2 ) Performs the intersection of this plane with the given plane Source code in pydelling/utils/geometry/intersections.py def intersect_plane_plane ( plane_1 : Plane , plane_2 : Plane ): \"\"\"Performs the intersection of this plane with the given plane\"\"\" if plane_1 . is_parallel ( plane_2 ): return None normal_a = plane_1 . n normal_b = plane_2 . n d_a = np . dot ( plane_1 . p , plane_1 . n ) d_b = np . dot ( plane_2 . p , plane_2 . n ) U = np . cross ( normal_a , normal_b ) M = np . array (( normal_a , normal_b , U )) X = np . array ([ d_a , d_b , 0.0 ]) . reshape ( 3 , 1 ) # print(M) p_inter = np . linalg . solve ( M , X ) . T p1 = p_inter [ 0 ] p2 = ( p_inter + U )[ 0 ] intersected_line = Line ( p1 , p2 ) return intersected_line intersect_plane_segment ( plane , segment ) Performs the intersection of this plane with the given segment Source code in pydelling/utils/geometry/intersections.py def intersect_plane_segment ( plane : Plane , segment : Segment ): \"\"\"Performs the intersection of this plane with the given segment\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - segment . p1 ) dot_n_v = np . dot ( plane . n , segment . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v intersection_point = Point ( segment . p1 + lambda_ * segment . direction_vector ) if segment . contains ( intersection_point ): return intersection_point else : return None","title":"General utilities"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Plane","text":"","title":"Plane"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Plane.Plane","text":"Source code in pydelling/utils/geometry/Plane.py class Plane ( BasePrimitive ): def __init__ ( self , point : Point or List or np . ndarray , normal : List or Vector or np . ndarray ): self . p = Point ( point ) self . n = Vector ( normal ) def __repr__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def __str__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" ) def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True","title":"Plane"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Plane.Plane.intersect","text":"Returns the intersection of this plane with the given primitive Source code in pydelling/utils/geometry/Plane.py def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" )","title":"intersect()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Plane.Plane.is_parallel","text":"Returns True if this plane is parallel to the given plane Source code in pydelling/utils/geometry/Plane.py def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True","title":"is_parallel()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Point","text":"","title":"Point"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Point.Point","text":"Source code in pydelling/utils/geometry/Point.py class Point ( np . ndarray ): def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ())) def __repr__ ( self ): return f \"Point( { self } )\" @property def x ( self ): return self [ 0 ] @property def y ( self ): return self [ 1 ] @property def z ( self ): return self [ 2 ]","title":"Point"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Point.Point.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Point.py def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj","title":"__new__()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Point.Point.distance","text":"Computes euclidean distance between two points Source code in pydelling/utils/geometry/Point.py def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ()))","title":"distance()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Vector","text":"","title":"Vector"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Vector.Vector","text":"Source code in pydelling/utils/geometry/Vector.py class Vector ( np . ndarray , BasePrimitive ): coords : np . ndarray def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" ) def __repr__ ( self ): return f \"Vector( { self } )\"","title":"Vector"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.Vector.Vector.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Vector.py def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" )","title":"__new__()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.intersections","text":"","title":"intersections"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.intersections.intersect_plane_line","text":"Performs the intersection of this plane with the given line Source code in pydelling/utils/geometry/intersections.py def intersect_plane_line ( plane : Plane , line : Line ): \"\"\"Performs the intersection of this plane with the given line\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - line . p ) dot_n_v = np . dot ( plane . n , line . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v return Point ( line . p + lambda_ * line . direction_vector )","title":"intersect_plane_line()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.intersections.intersect_plane_plane","text":"Performs the intersection of this plane with the given plane Source code in pydelling/utils/geometry/intersections.py def intersect_plane_plane ( plane_1 : Plane , plane_2 : Plane ): \"\"\"Performs the intersection of this plane with the given plane\"\"\" if plane_1 . is_parallel ( plane_2 ): return None normal_a = plane_1 . n normal_b = plane_2 . n d_a = np . dot ( plane_1 . p , plane_1 . n ) d_b = np . dot ( plane_2 . p , plane_2 . n ) U = np . cross ( normal_a , normal_b ) M = np . array (( normal_a , normal_b , U )) X = np . array ([ d_a , d_b , 0.0 ]) . reshape ( 3 , 1 ) # print(M) p_inter = np . linalg . solve ( M , X ) . T p1 = p_inter [ 0 ] p2 = ( p_inter + U )[ 0 ] intersected_line = Line ( p1 , p2 ) return intersected_line","title":"intersect_plane_plane()"},{"location":"utilities/docs-utilities-general/#pydelling.utils.geometry.intersections.intersect_plane_segment","text":"Performs the intersection of this plane with the given segment Source code in pydelling/utils/geometry/intersections.py def intersect_plane_segment ( plane : Plane , segment : Segment ): \"\"\"Performs the intersection of this plane with the given segment\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - segment . p1 ) dot_n_v = np . dot ( plane . n , segment . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v intersection_point = Point ( segment . p1 + lambda_ * segment . direction_vector ) if segment . contains ( intersection_point ): return intersection_point else : return None","title":"intersect_plane_segment()"},{"location":"utilities/docs-utilities-geometry/","text":"Plane Plane ( BasePrimitive ) Source code in pydelling/utils/geometry/Plane.py class Plane ( BasePrimitive ): def __init__ ( self , point : Point or List or np . ndarray , normal : List or Vector or np . ndarray ): self . p = Point ( point ) self . n = Vector ( normal ) def __repr__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def __str__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" ) def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True intersect ( self , primitive ) Returns the intersection of this plane with the given primitive Source code in pydelling/utils/geometry/Plane.py def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" ) is_parallel ( self , plane ) Returns True if this plane is parallel to the given plane Source code in pydelling/utils/geometry/Plane.py def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True Point Point ( ndarray ) Source code in pydelling/utils/geometry/Point.py class Point ( np . ndarray ): def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ())) def __repr__ ( self ): return f \"Point( { self } )\" @property def x ( self ): return self [ 0 ] @property def y ( self ): return self [ 1 ] @property def z ( self ): return self [ 2 ] __new__ ( cls , input_array ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Point.py def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj distance ( self , p ) Computes euclidean distance between two points Source code in pydelling/utils/geometry/Point.py def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ())) Vector Vector ( ndarray , BasePrimitive ) Source code in pydelling/utils/geometry/Vector.py class Vector ( np . ndarray , BasePrimitive ): coords : np . ndarray def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" ) def __repr__ ( self ): return f \"Vector( { self } )\" __new__ ( cls , v = None , p1 = None , p2 = None , * args , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Vector.py def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" ) intersections intersect_plane_line ( plane , line ) Performs the intersection of this plane with the given line Source code in pydelling/utils/geometry/intersections.py def intersect_plane_line ( plane : Plane , line : Line ): \"\"\"Performs the intersection of this plane with the given line\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - line . p ) dot_n_v = np . dot ( plane . n , line . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v return Point ( line . p + lambda_ * line . direction_vector ) intersect_plane_plane ( plane_1 , plane_2 ) Performs the intersection of this plane with the given plane Source code in pydelling/utils/geometry/intersections.py def intersect_plane_plane ( plane_1 : Plane , plane_2 : Plane ): \"\"\"Performs the intersection of this plane with the given plane\"\"\" if plane_1 . is_parallel ( plane_2 ): return None normal_a = plane_1 . n normal_b = plane_2 . n d_a = np . dot ( plane_1 . p , plane_1 . n ) d_b = np . dot ( plane_2 . p , plane_2 . n ) U = np . cross ( normal_a , normal_b ) M = np . array (( normal_a , normal_b , U )) X = np . array ([ d_a , d_b , 0.0 ]) . reshape ( 3 , 1 ) # print(M) p_inter = np . linalg . solve ( M , X ) . T p1 = p_inter [ 0 ] p2 = ( p_inter + U )[ 0 ] intersected_line = Line ( p1 , p2 ) return intersected_line intersect_plane_segment ( plane , segment ) Performs the intersection of this plane with the given segment Source code in pydelling/utils/geometry/intersections.py def intersect_plane_segment ( plane : Plane , segment : Segment ): \"\"\"Performs the intersection of this plane with the given segment\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - segment . p1 ) dot_n_v = np . dot ( plane . n , segment . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v intersection_point = Point ( segment . p1 + lambda_ * segment . direction_vector ) if segment . contains ( intersection_point ): return intersection_point else : return None","title":"Geometry operations"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Plane","text":"","title":"Plane"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Plane.Plane","text":"Source code in pydelling/utils/geometry/Plane.py class Plane ( BasePrimitive ): def __init__ ( self , point : Point or List or np . ndarray , normal : List or Vector or np . ndarray ): self . p = Point ( point ) self . n = Vector ( normal ) def __repr__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def __str__ ( self ): return f \"Plane(point: { self . p } , normal: { self . n } )\" def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" ) def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True","title":"Plane"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Plane.Plane.intersect","text":"Returns the intersection of this plane with the given primitive Source code in pydelling/utils/geometry/Plane.py def intersect ( self , primitive : BasePrimitive ): \"\"\"Returns the intersection of this plane with the given primitive\"\"\" from .intersections import intersect_plane_plane , intersect_plane_line , intersect_plane_segment if primitive . __class__ . __name__ == \"Plane\" : return intersect_plane_plane ( plane_1 = self , plane_2 = primitive ) elif primitive . __class__ . __name__ == \"Line\" : return intersect_plane_line ( plane = self , line = primitive ) elif primitive . __class__ . __name__ == 'Segment' : return intersect_plane_segment ( plane = self , segment = primitive ) else : raise NotImplementedError ( f \"Intersection with { type ( primitive ) } is not implemented\" )","title":"intersect()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Plane.Plane.is_parallel","text":"Returns True if this plane is parallel to the given plane Source code in pydelling/utils/geometry/Plane.py def is_parallel ( self , plane : Plane ): \"\"\"Returns True if this plane is parallel to the given plane\"\"\" if np . isclose ( np . dot ( self . n , plane . n ), 1 ): return True if np . isclose ( np . dot ( self . n , plane . n ), - 1 ): return True","title":"is_parallel()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Point","text":"","title":"Point"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Point.Point","text":"Source code in pydelling/utils/geometry/Point.py class Point ( np . ndarray ): def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ())) def __repr__ ( self ): return f \"Point( { self } )\" @property def x ( self ): return self [ 0 ] @property def y ( self ): return self [ 1 ] @property def z ( self ): return self [ 2 ]","title":"Point"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Point.Point.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Point.py def __new__ ( cls , input_array ): # Input array is an already formed ndarray instance # We first cast to be our class type if len ( input_array ) == 1 : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) elif len ( input_array ) == 2 : obj = np . asarray ( input_array ) . view ( cls ) elif len ( input_array ) == 3 : obj = np . asarray ( input_array ) . view ( cls ) else : raise ValueError ( \"Point must have 2 or 3 coordinates\" ) return obj","title":"__new__()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Point.Point.distance","text":"Computes euclidean distance between two points Source code in pydelling/utils/geometry/Point.py def distance ( self , p : Point ): \"\"\"Computes euclidean distance between two points\"\"\" diff = self - p return float ( np . sqrt (( diff ** 2 ) . sum ()))","title":"distance()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Vector","text":"","title":"Vector"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Vector.Vector","text":"Source code in pydelling/utils/geometry/Vector.py class Vector ( np . ndarray , BasePrimitive ): coords : np . ndarray def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" ) def __repr__ ( self ): return f \"Vector( { self } )\"","title":"Vector"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.Vector.Vector.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pydelling/utils/geometry/Vector.py def __new__ ( cls , v : np . ndarray or List = None , p1 : Point or List or np . ndarray = None , p2 : Point or List or np . ndarray = None , * args , ** kwargs ): if v is not None : assert len ( v ) >= 2 , \"Vector must have 2 or 3 coordinates\" if isinstance ( v , Vector ): obj = np . asarray ( v ) . view ( cls ) else : obj = np . asarray ( v ) . view ( cls ) return obj elif p1 is not None and p2 is not None : p1 = Point ( p1 ) p2 = Point ( p2 ) obj = np . asarray ( p2 - p1 ) . view ( cls ) return obj else : raise ValueError ( \"Vector must be initialized with either a list or a numpy array\" )","title":"__new__()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.intersections","text":"","title":"intersections"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.intersections.intersect_plane_line","text":"Performs the intersection of this plane with the given line Source code in pydelling/utils/geometry/intersections.py def intersect_plane_line ( plane : Plane , line : Line ): \"\"\"Performs the intersection of this plane with the given line\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - line . p ) dot_n_v = np . dot ( plane . n , line . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v return Point ( line . p + lambda_ * line . direction_vector )","title":"intersect_plane_line()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.intersections.intersect_plane_plane","text":"Performs the intersection of this plane with the given plane Source code in pydelling/utils/geometry/intersections.py def intersect_plane_plane ( plane_1 : Plane , plane_2 : Plane ): \"\"\"Performs the intersection of this plane with the given plane\"\"\" if plane_1 . is_parallel ( plane_2 ): return None normal_a = plane_1 . n normal_b = plane_2 . n d_a = np . dot ( plane_1 . p , plane_1 . n ) d_b = np . dot ( plane_2 . p , plane_2 . n ) U = np . cross ( normal_a , normal_b ) M = np . array (( normal_a , normal_b , U )) X = np . array ([ d_a , d_b , 0.0 ]) . reshape ( 3 , 1 ) # print(M) p_inter = np . linalg . solve ( M , X ) . T p1 = p_inter [ 0 ] p2 = ( p_inter + U )[ 0 ] intersected_line = Line ( p1 , p2 ) return intersected_line","title":"intersect_plane_plane()"},{"location":"utilities/docs-utilities-geometry/#pydelling.utils.geometry.intersections.intersect_plane_segment","text":"Performs the intersection of this plane with the given segment Source code in pydelling/utils/geometry/intersections.py def intersect_plane_segment ( plane : Plane , segment : Segment ): \"\"\"Performs the intersection of this plane with the given segment\"\"\" # The point r = q + lambda * v dot_n_diff = np . dot ( plane . n , plane . p - segment . p1 ) dot_n_v = np . dot ( plane . n , segment . direction_vector ) if dot_n_v == 0 : # Plane and line are parallel return None else : lambda_ = dot_n_diff / dot_n_v intersection_point = Point ( segment . p1 + lambda_ * segment . direction_vector ) if segment . contains ( intersection_point ): return intersection_point else : return None","title":"intersect_plane_segment()"},{"location":"writers/docs-writers-openfoam_variable/","text":"OpenFoamVariableWriter ( BaseWriter ) This class creates an OpenFOAM variable data file Source code in pydelling/writers/OpenFoamVariableWriter.py class OpenFoamVariableWriter ( BaseWriter ): \"\"\"This class creates an OpenFOAM variable data file\"\"\" def __init__ ( self , filename : str = None , header = None , outer = None , data = None , configuration_dict = None , * args , ** kwargs ): \"\"\" A correct set of header/outer needs to be provided to the class. It can be automatically used from the config file by creating an instance called \"open_foam_variable_writer\" for the settings. Args: filename: Name of the output file header: Dictionary containing the header variables outer: Dictioanary containing the end variables data: Data to be set into the OpenFOAM file \"\"\" if configuration_dict : self . header = configuration_dict . header self . outer = configuration_dict . outer self . filename = configuration_dict . filename else : self . header = header if header else config . open_foam_variable_writer . header self . outer = outer if outer else config . open_foam_variable_writer . outer self . filename = filename if filename else config . open_foam_variable_writer . filename self . data = data super () . __init__ ( filename = self . filename , * args , ** kwargs ) def run ( self , * args , ** kwargs ): \"\"\" Writes the data into an OpenFOAM variable format \"\"\" logger . info ( f \"Writing data to { self . filename } \" ) with open ( self . filename , \"w\" ) as self . output_file : self . write_header () self . write_data () self . write_outer () def write_header ( self ): \"\"\" Writes the header of the file \"\"\" self . output_file . write ( f \"\"\"/*--------------------------------*- C++ -*----------------------------------* \\\\ ========= | \\\\ \\ / F ield | OpenFOAM: The Open Source CFD Toolbox \\\\ \\ / O peration | Website: https://openfoam.org \\\\ \\ / A nd | Version: 7 \\\\ \\/ M anipulation | \\*---------------------------------------------------------------------------*/ FoamFile {{ version 2.0; format ascii; class { self . header . field_type } ; location \" { self . header . location } \"; object { self . header . object } ; }} // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dimensions { self . header . dimensions } ; internalField { self . header . data_type } { self . header . data_structure } \\n \"\"\" ) def write_data ( self ): self . output_file . write ( f \" { len ( self . data ) } \\n \" ) self . output_file . write ( \"( \\n \" ) for data_element in self . data : if type ( data_element ) == np . float64 or type ( data_element ) == np . float32 : self . output_file . write ( f \" { data_element } \\n \" ) elif len ( data_element ) == 4 : self . output_file . write ( f \" { data_element [ 3 ] } \\n \" ) else : logger . error ( \"There is an error provided the data element vector\" ) raise ValueError ( \"There was an error providing the data element\" ) self . output_file . write ( \") \\n \" ) self . output_file . write ( \"; \\n \" ) def write_outer ( self ): self . output_file . write ( f \"\"\"boundaryField \\n{{\\n \"\"\" ) for region in self . outer . boundary_fields : region_dict = self . outer . boundary_fields [ region ] self . output_file . write ( f \"\"\" \\t { region } \\n\\t{{\\n\\t\\t type \\t { region_dict [ \"type\" ] } ; \\n\\t}}\\n \"\"\" ) self . output_file . write ( \"} \\n \" ) self . output_file . write ( \" \\n \" ) self . output_file . write ( \"// ************************************************************************* //\" ) __init__ ( self , filename = None , header = None , outer = None , data = None , configuration_dict = None , * args , ** kwargs ) special A correct set of header/outer needs to be provided to the class. It can be automatically used from the config file by creating an instance called \"open_foam_variable_writer\" for the settings. Parameters: Name Type Description Default filename str Name of the output file None header Dictionary containing the header variables None outer Dictioanary containing the end variables None data Data to be set into the OpenFOAM file None Source code in pydelling/writers/OpenFoamVariableWriter.py def __init__ ( self , filename : str = None , header = None , outer = None , data = None , configuration_dict = None , * args , ** kwargs ): \"\"\" A correct set of header/outer needs to be provided to the class. It can be automatically used from the config file by creating an instance called \"open_foam_variable_writer\" for the settings. Args: filename: Name of the output file header: Dictionary containing the header variables outer: Dictioanary containing the end variables data: Data to be set into the OpenFOAM file \"\"\" if configuration_dict : self . header = configuration_dict . header self . outer = configuration_dict . outer self . filename = configuration_dict . filename else : self . header = header if header else config . open_foam_variable_writer . header self . outer = outer if outer else config . open_foam_variable_writer . outer self . filename = filename if filename else config . open_foam_variable_writer . filename self . data = data super () . __init__ ( filename = self . filename , * args , ** kwargs ) run ( self , * args , ** kwargs ) Writes the data into an OpenFOAM variable format Source code in pydelling/writers/OpenFoamVariableWriter.py def run ( self , * args , ** kwargs ): \"\"\" Writes the data into an OpenFOAM variable format \"\"\" logger . info ( f \"Writing data to { self . filename } \" ) with open ( self . filename , \"w\" ) as self . output_file : self . write_header () self . write_data () self . write_outer () write_header ( self ) Writes the header of the file Source code in pydelling/writers/OpenFoamVariableWriter.py def write_header ( self ): \"\"\" Writes the header of the file \"\"\" self . output_file . write ( f \"\"\"/*--------------------------------*- C++ -*----------------------------------* \\\\ ========= | \\\\ \\ / F ield | OpenFOAM: The Open Source CFD Toolbox \\\\ \\ / O peration | Website: https://openfoam.org \\\\ \\ / A nd | Version: 7 \\\\ \\/ M anipulation | \\*---------------------------------------------------------------------------*/ FoamFile {{ version 2.0; format ascii; class { self . header . field_type } ; location \" { self . header . location } \"; object { self . header . object } ; }} // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dimensions { self . header . dimensions } ; internalField { self . header . data_type } { self . header . data_structure } \\n \"\"\" )","title":"OpenFOAM variable writer"},{"location":"writers/docs-writers-openfoam_variable/#pydelling.writers.OpenFoamVariableWriter.OpenFoamVariableWriter","text":"This class creates an OpenFOAM variable data file Source code in pydelling/writers/OpenFoamVariableWriter.py class OpenFoamVariableWriter ( BaseWriter ): \"\"\"This class creates an OpenFOAM variable data file\"\"\" def __init__ ( self , filename : str = None , header = None , outer = None , data = None , configuration_dict = None , * args , ** kwargs ): \"\"\" A correct set of header/outer needs to be provided to the class. It can be automatically used from the config file by creating an instance called \"open_foam_variable_writer\" for the settings. Args: filename: Name of the output file header: Dictionary containing the header variables outer: Dictioanary containing the end variables data: Data to be set into the OpenFOAM file \"\"\" if configuration_dict : self . header = configuration_dict . header self . outer = configuration_dict . outer self . filename = configuration_dict . filename else : self . header = header if header else config . open_foam_variable_writer . header self . outer = outer if outer else config . open_foam_variable_writer . outer self . filename = filename if filename else config . open_foam_variable_writer . filename self . data = data super () . __init__ ( filename = self . filename , * args , ** kwargs ) def run ( self , * args , ** kwargs ): \"\"\" Writes the data into an OpenFOAM variable format \"\"\" logger . info ( f \"Writing data to { self . filename } \" ) with open ( self . filename , \"w\" ) as self . output_file : self . write_header () self . write_data () self . write_outer () def write_header ( self ): \"\"\" Writes the header of the file \"\"\" self . output_file . write ( f \"\"\"/*--------------------------------*- C++ -*----------------------------------* \\\\ ========= | \\\\ \\ / F ield | OpenFOAM: The Open Source CFD Toolbox \\\\ \\ / O peration | Website: https://openfoam.org \\\\ \\ / A nd | Version: 7 \\\\ \\/ M anipulation | \\*---------------------------------------------------------------------------*/ FoamFile {{ version 2.0; format ascii; class { self . header . field_type } ; location \" { self . header . location } \"; object { self . header . object } ; }} // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dimensions { self . header . dimensions } ; internalField { self . header . data_type } { self . header . data_structure } \\n \"\"\" ) def write_data ( self ): self . output_file . write ( f \" { len ( self . data ) } \\n \" ) self . output_file . write ( \"( \\n \" ) for data_element in self . data : if type ( data_element ) == np . float64 or type ( data_element ) == np . float32 : self . output_file . write ( f \" { data_element } \\n \" ) elif len ( data_element ) == 4 : self . output_file . write ( f \" { data_element [ 3 ] } \\n \" ) else : logger . error ( \"There is an error provided the data element vector\" ) raise ValueError ( \"There was an error providing the data element\" ) self . output_file . write ( \") \\n \" ) self . output_file . write ( \"; \\n \" ) def write_outer ( self ): self . output_file . write ( f \"\"\"boundaryField \\n{{\\n \"\"\" ) for region in self . outer . boundary_fields : region_dict = self . outer . boundary_fields [ region ] self . output_file . write ( f \"\"\" \\t { region } \\n\\t{{\\n\\t\\t type \\t { region_dict [ \"type\" ] } ; \\n\\t}}\\n \"\"\" ) self . output_file . write ( \"} \\n \" ) self . output_file . write ( \" \\n \" ) self . output_file . write ( \"// ************************************************************************* //\" )","title":"OpenFoamVariableWriter"},{"location":"writers/docs-writers-openfoam_variable/#pydelling.writers.OpenFoamVariableWriter.OpenFoamVariableWriter.__init__","text":"A correct set of header/outer needs to be provided to the class. It can be automatically used from the config file by creating an instance called \"open_foam_variable_writer\" for the settings. Parameters: Name Type Description Default filename str Name of the output file None header Dictionary containing the header variables None outer Dictioanary containing the end variables None data Data to be set into the OpenFOAM file None Source code in pydelling/writers/OpenFoamVariableWriter.py def __init__ ( self , filename : str = None , header = None , outer = None , data = None , configuration_dict = None , * args , ** kwargs ): \"\"\" A correct set of header/outer needs to be provided to the class. It can be automatically used from the config file by creating an instance called \"open_foam_variable_writer\" for the settings. Args: filename: Name of the output file header: Dictionary containing the header variables outer: Dictioanary containing the end variables data: Data to be set into the OpenFOAM file \"\"\" if configuration_dict : self . header = configuration_dict . header self . outer = configuration_dict . outer self . filename = configuration_dict . filename else : self . header = header if header else config . open_foam_variable_writer . header self . outer = outer if outer else config . open_foam_variable_writer . outer self . filename = filename if filename else config . open_foam_variable_writer . filename self . data = data super () . __init__ ( filename = self . filename , * args , ** kwargs )","title":"__init__()"},{"location":"writers/docs-writers-openfoam_variable/#pydelling.writers.OpenFoamVariableWriter.OpenFoamVariableWriter.run","text":"Writes the data into an OpenFOAM variable format Source code in pydelling/writers/OpenFoamVariableWriter.py def run ( self , * args , ** kwargs ): \"\"\" Writes the data into an OpenFOAM variable format \"\"\" logger . info ( f \"Writing data to { self . filename } \" ) with open ( self . filename , \"w\" ) as self . output_file : self . write_header () self . write_data () self . write_outer ()","title":"run()"},{"location":"writers/docs-writers-openfoam_variable/#pydelling.writers.OpenFoamVariableWriter.OpenFoamVariableWriter.write_header","text":"Writes the header of the file Source code in pydelling/writers/OpenFoamVariableWriter.py def write_header ( self ): \"\"\" Writes the header of the file \"\"\" self . output_file . write ( f \"\"\"/*--------------------------------*- C++ -*----------------------------------* \\\\ ========= | \\\\ \\ / F ield | OpenFOAM: The Open Source CFD Toolbox \\\\ \\ / O peration | Website: https://openfoam.org \\\\ \\ / A nd | Version: 7 \\\\ \\/ M anipulation | \\*---------------------------------------------------------------------------*/ FoamFile {{ version 2.0; format ascii; class { self . header . field_type } ; location \" { self . header . location } \"; object { self . header . object } ; }} // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * // dimensions { self . header . dimensions } ; internalField { self . header . data_type } { self . header . data_structure } \\n \"\"\" )","title":"write_header()"},{"location":"writers/docs-writers-pflotran_hdf5_centroid/","text":"HDF5CentroidWriter ( BaseWriter ) Source code in pydelling/writers/HDF5CentroidWriter.py class HDF5CentroidWriter ( BaseWriter ): def run ( self , filename = None , remove_if_exists = True , include_cell_id = True ): if filename is not None : self . filename = filename if remove_if_exists : try : os . remove ( self . filename ) except FileNotFoundError as ef : print ( \"Nothing to overwrite!\" ) if self . check_data (): if not os . path . exists ( self . filename ): h5temp = h5py . File ( self . filename , \"w\" ) h5temp . close () with h5py . File ( self . filename , \"r+\" ) as h5temp : h5temp . create_dataset ( self . var_name , data = self . data ) if include_cell_id : cell_id = np . array ([ index + 1 for index in range ( len ( self . data ))]) h5temp . create_dataset ( \"Cell Ids\" , data = cell_id ) else : print ( \"Couldn't find data to dump!\" ) def write_anisotropic_dataset ( self , dataset_x , dataset_y , dataset_z , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes anisotropic dataset to HDF5 Args: filename: name of the file dataset_x: dataset containing data in the x-direction dataset_y: dataset containing data in the y-direction dataset_z: dataset containing data in the z-direction remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } X\" , data = dataset_x ) h5_temp . create_dataset ( f \" { var_name_write } Y\" , data = dataset_y ) h5_temp . create_dataset ( f \" { var_name_write } Z\" , data = dataset_z ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset_x ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id ) def write_dataset ( self , dataset , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes isotropic dataset to HDF5 Args: filename: name of the file dataset_x: output dataset remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } \" , data = dataset ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id ) write_anisotropic_dataset ( self , dataset_x , dataset_y , dataset_z , filename = None , remove_if_exists = True , var_name = None ) Writes anisotropic dataset to HDF5 Parameters: Name Type Description Default filename name of the file None dataset_x dataset containing data in the x-direction required dataset_y dataset containing data in the y-direction required dataset_z dataset containing data in the z-direction required remove_if_exists removes file if exists True Source code in pydelling/writers/HDF5CentroidWriter.py def write_anisotropic_dataset ( self , dataset_x , dataset_y , dataset_z , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes anisotropic dataset to HDF5 Args: filename: name of the file dataset_x: dataset containing data in the x-direction dataset_y: dataset containing data in the y-direction dataset_z: dataset containing data in the z-direction remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } X\" , data = dataset_x ) h5_temp . create_dataset ( f \" { var_name_write } Y\" , data = dataset_y ) h5_temp . create_dataset ( f \" { var_name_write } Z\" , data = dataset_z ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset_x ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id ) write_dataset ( self , dataset , filename = None , remove_if_exists = True , var_name = None ) Writes isotropic dataset to HDF5 Parameters: Name Type Description Default filename name of the file None dataset_x output dataset required remove_if_exists removes file if exists True Source code in pydelling/writers/HDF5CentroidWriter.py def write_dataset ( self , dataset , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes isotropic dataset to HDF5 Args: filename: name of the file dataset_x: output dataset remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } \" , data = dataset ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id )","title":"PFLOTRAN HDF5 centroid writer"},{"location":"writers/docs-writers-pflotran_hdf5_centroid/#pydelling.writers.HDF5CentroidWriter.HDF5CentroidWriter","text":"Source code in pydelling/writers/HDF5CentroidWriter.py class HDF5CentroidWriter ( BaseWriter ): def run ( self , filename = None , remove_if_exists = True , include_cell_id = True ): if filename is not None : self . filename = filename if remove_if_exists : try : os . remove ( self . filename ) except FileNotFoundError as ef : print ( \"Nothing to overwrite!\" ) if self . check_data (): if not os . path . exists ( self . filename ): h5temp = h5py . File ( self . filename , \"w\" ) h5temp . close () with h5py . File ( self . filename , \"r+\" ) as h5temp : h5temp . create_dataset ( self . var_name , data = self . data ) if include_cell_id : cell_id = np . array ([ index + 1 for index in range ( len ( self . data ))]) h5temp . create_dataset ( \"Cell Ids\" , data = cell_id ) else : print ( \"Couldn't find data to dump!\" ) def write_anisotropic_dataset ( self , dataset_x , dataset_y , dataset_z , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes anisotropic dataset to HDF5 Args: filename: name of the file dataset_x: dataset containing data in the x-direction dataset_y: dataset containing data in the y-direction dataset_z: dataset containing data in the z-direction remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } X\" , data = dataset_x ) h5_temp . create_dataset ( f \" { var_name_write } Y\" , data = dataset_y ) h5_temp . create_dataset ( f \" { var_name_write } Z\" , data = dataset_z ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset_x ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id ) def write_dataset ( self , dataset , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes isotropic dataset to HDF5 Args: filename: name of the file dataset_x: output dataset remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } \" , data = dataset ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id )","title":"HDF5CentroidWriter"},{"location":"writers/docs-writers-pflotran_hdf5_centroid/#pydelling.writers.HDF5CentroidWriter.HDF5CentroidWriter.write_anisotropic_dataset","text":"Writes anisotropic dataset to HDF5 Parameters: Name Type Description Default filename name of the file None dataset_x dataset containing data in the x-direction required dataset_y dataset containing data in the y-direction required dataset_z dataset containing data in the z-direction required remove_if_exists removes file if exists True Source code in pydelling/writers/HDF5CentroidWriter.py def write_anisotropic_dataset ( self , dataset_x , dataset_y , dataset_z , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes anisotropic dataset to HDF5 Args: filename: name of the file dataset_x: dataset containing data in the x-direction dataset_y: dataset containing data in the y-direction dataset_z: dataset containing data in the z-direction remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } X\" , data = dataset_x ) h5_temp . create_dataset ( f \" { var_name_write } Y\" , data = dataset_y ) h5_temp . create_dataset ( f \" { var_name_write } Z\" , data = dataset_z ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset_x ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id )","title":"write_anisotropic_dataset()"},{"location":"writers/docs-writers-pflotran_hdf5_centroid/#pydelling.writers.HDF5CentroidWriter.HDF5CentroidWriter.write_dataset","text":"Writes isotropic dataset to HDF5 Parameters: Name Type Description Default filename name of the file None dataset_x output dataset required remove_if_exists removes file if exists True Source code in pydelling/writers/HDF5CentroidWriter.py def write_dataset ( self , dataset , filename = None , remove_if_exists = True , var_name = None , ): \"\"\" Writes isotropic dataset to HDF5 Args: filename: name of the file dataset_x: output dataset remove_if_exists: removes file if exists \"\"\" filename_path = Path ( filename if filename else self . filename ) logger . info ( f \"Writing anisotropic permeability to { filename_path } \" ) if remove_if_exists : if filename_path . exists (): filename_path . unlink () with h5py . File ( filename_path , \"w\" ) as h5_temp : var_name_write = var_name if var_name else self . var_name h5_temp . create_dataset ( f \" { var_name_write } \" , data = dataset ) cell_id = np . array ([ index + 1 for index in range ( len ( dataset ))]) h5_temp . create_dataset ( \"Cell Ids\" , data = cell_id )","title":"write_dataset()"},{"location":"writers/docs-writers-pflotran_hdf5_raster/","text":"","title":"PFLOTRAN HDF5 raster writer"}]}