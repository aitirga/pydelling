{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Index","title":"Index"},{"location":"#index","text":"","title":"Index"},{"location":"docs-getting_started/","text":"Getting Started","title":"Getting started"},{"location":"docs-getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"docs-installation/","text":"Installation","title":"Installation"},{"location":"docs-installation/#installation","text":"","title":"Installation"},{"location":"docs-interpolation-kde/","text":"This class performs a KDE estimation on a given dataset and provides useful methods to plot and manipulate the estimated distributions. Source code in class KdeEstimator : \"\"\" This class performs a KDE estimation on a given dataset and provides useful methods to plot and manipulate the estimated distributions. \"\"\" is_run : bool kde_estimator : KernelDensity def __init__ ( self , data : pd . DataFrame = None , kernel = 'gaussian' , bandwidth = 1000 , package = 'scikit' ): self . data = data self . kernel = kernel self . bandwidth = bandwidth self . package = package if type ( self . data ) == pd . Series : self . data = pd . DataFrame ( self . data ) @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator def plot_1d_comparison_histograms ( self , variable = None , n = 10000 , savefig = None , bins = 30 , colors = None , xlabel = None , ylabel = None ): plt . clf () fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes if not variable : variable = self . data . columns [ 0 ] sampled_values = pd . DataFrame ( self . kde_estimator . sample ( n ), columns = self . data . columns ) ax . hist ( self . data [ variable ] . values , bins = bins , density = True , alpha = 0.5 , label = variable , color = colors [ 0 ] if colors else 'C0' ) ax . hist ( sampled_values [ variable ] . values , bins = bins , density = True , alpha = 0.5 , label = f \" { variable } -kde\" , color = colors [ 1 ] if colors else 'C1' ) ax . set_axisbelow ( True ) if xlabel : ax . set_xlabel ( xlabel ) if ylabel : ax . set_ylabel ( ylabel ) plt . legend () plt . grid () if savefig : plt . savefig ( savefig ) else : plt . show () return ax def plot_1d_comparison_histograms_multi ( self , variables , n = 10000 , savefig = None , bins = 30 , palette = None , dpi = 150 ): plt . clf () fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes sampled_values = pd . DataFrame ( self . kde_estimator . sample ( n ), columns = self . data . columns ) for idx , variable in enumerate ( variables ): if palette : color = palette [ idx ] sns . histplot ( self . data [ variable ] . values , bins = bins , alpha = 0.75 , label = variable , color = color if palette else {} ) sns . histplot ( sampled_values [ variable ] . values , bins = bins , alpha = 0.25 , label = f \" { variable } -kde\" , color = color if palette else {} ) ax . set_axisbelow ( True ) plt . legend () plt . grid () if savefig : plt . savefig ( savefig , dpi = dpi ) else : plt . show () return ax def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax @property def _training_data ( self ): assert not self . data . empty , 'Provide some data to work with' return self . data . values . reshape ( - 1 , self . data . shape [ 1 ]) def sample ( self , * args , ** kwargs ): return self . kde_estimator . sample ( * args , ** kwargs ) plot_1d ( self , variable = None , n = 100 , savefig = None ) Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot Source code in def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax run ( self , data = None ) Fit the provided dataset to the corresponding kernel distribution Source code in @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator","title":"KDE estimator"},{"location":"docs-interpolation-kde/#pydelling.interpolation.KdeEstimator.KdeEstimator.plot_1d","text":"Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot Source code in def plot_1d ( self , variable = None , n = 100 , savefig = None ): \"\"\" Plots the trained KDE using the original data bounds Returns: Axes object of the generated plot \"\"\" plt . clf () if not variable : variable = self . data . columns [ 0 ] logger . info ( f 'Generating 1D comparison plot for { variable } variable' ) temp = [ np . linspace ( self . data [ column ] . min (), self . data [ column ] . max (), n ) for column in self . data ] sampling_data = np . meshgrid ( * temp ) sampling_data : np . ndarray = np . vstack ( map ( np . ravel , sampling_data )) . T . reshape ( - 1 , self . data . shape [ 1 ]) predicted_distribution = self . kde_estimator . score_samples ( sampling_data ) predicted_distribution = np . exp ( predicted_distribution ) # Plot result fig , ax = plt . subplots () fig : plt . Figure ax : plt . Axes ax . hist ( self . data [ variable ] . values , bins = 30 , density = True , alpha = 0.5 , label = variable , ) ax . plot ( sampling_data , predicted_distribution , alpha = 0.80 , label = f ' { variable } -predicted KDE' ) plt . legend () plt . grid () ax . set_ylabel ( 'Density [-]' ) ax . set_xlabel ( 'Integration time [y]' ) if savefig : plt . savefig ( savefig ) else : plt . show () return ax","title":"plot_1d()"},{"location":"docs-interpolation-kde/#pydelling.interpolation.KdeEstimator.KdeEstimator.run","text":"Fit the provided dataset to the corresponding kernel distribution Source code in @set_run def run ( self , data : pd . DataFrame = None ): \"\"\" Fit the provided dataset to the corresponding kernel distribution \"\"\" if data : self . data = data logger . info ( f 'Fitting KDE generator for { self . data . columns . to_list () } variables' ) self . kde_estimator : KernelDensity = KernelDensity ( kernel = self . kernel , bandwidth = self . bandwidth ) . fit ( self . _training_data ) return self . kde_estimator","title":"run()"},{"location":"docs-interpolation-sparse/","text":"Interpolates a given set of points into a PFLOTRAN mesh SparseDataInterpolator ( BaseInterpolator ) Source code in class SparseDataInterpolator ( BaseInterpolator ): divide_over_direction = None @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data () def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 ) def change_min_value ( self , min_value = None ): logger . info ( f \"Equaling values < { min_value } to { min_value } \" ) self . interpolated_data [ self . interpolated_data < min_value ] = min_value return self . interpolated_data def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data () def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' ) export_pointwise_data ( self , output_file = 'pointwise_data.csv' ) Exports the interpolated data to a csv data file Source code in def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' ) generate_pointwise_data ( self ) Generates a pointwise data file Source code in def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data get_data ( self ) Returns interpolated data :return: Source code in def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 ) plot_regular_mesh ( self ) Generates a plot of the interpolated data on a regular mesh Source code in def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data () run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ) Interpolates the data using the given method. Parameters: Name Type Description Default method interpolation method 'nearest' divide_over_direction Divides the data into smaller chunks if the data is too large. None **kwargs {} Returns: Type Description interpolated data Source code in @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data ()","title":"Sparse interpolator"},{"location":"docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator","text":"Source code in class SparseDataInterpolator ( BaseInterpolator ): divide_over_direction = None @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data () def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 ) def change_min_value ( self , min_value = None ): logger . info ( f \"Equaling values < { min_value } to { min_value } \" ) self . interpolated_data [ self . interpolated_data < min_value ] = min_value return self . interpolated_data def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data () def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' )","title":"SparseDataInterpolator"},{"location":"docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.export_pointwise_data","text":"Exports the interpolated data to a csv data file Source code in def export_pointwise_data ( self , output_file = 'pointwise_data.csv' ): \"\"\"Exports the interpolated data to a csv data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . generate_pointwise_data () np . savetxt ( output_file , mesh_data , delimiter = ',' , header = 'x,y,value' )","title":"export_pointwise_data()"},{"location":"docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.generate_pointwise_data","text":"Generates a pointwise data file Source code in def generate_pointwise_data ( self ): \"\"\"Generates a pointwise data file\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" mesh_data = self . mesh . copy () mesh_data = np . hstack (( mesh_data , np . reshape ( self . interpolated_data , ( - 1 , 1 )))) return mesh_data","title":"generate_pointwise_data()"},{"location":"docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.get_data","text":"Returns interpolated data :return: Source code in def get_data ( self ): temp_array = np . reshape ( self . interpolated_data , ( self . interpolated_data . shape [ 0 ], 1 )) return np . concatenate (( self . mesh , temp_array ), axis = 1 )","title":"get_data()"},{"location":"docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.plot_regular_mesh","text":"Generates a plot of the interpolated data on a regular mesh Source code in def plot_regular_mesh ( self ): \"\"\"Generates a plot of the interpolated data on a regular mesh\"\"\" assert self . is_run , \"The interpolator has not been run\" assert self . has_regular_mesh , \"The interpolator has not been run with a regular mesh\" import matplotlib.pyplot as plt fig , ax = plt . subplots () plot_data = self . get_data ()","title":"plot_regular_mesh()"},{"location":"docs-interpolation-sparse/#pydelling.interpolation.SparseDataInterpolator.SparseDataInterpolator.run","text":"Interpolates the data using the given method. Parameters: Name Type Description Default method interpolation method 'nearest' divide_over_direction Divides the data into smaller chunks if the data is too large. None **kwargs {} Returns: Type Description interpolated data Source code in @set_run def run ( self , method = 'nearest' , divide_over_direction = None , ** kwargs ): \"\"\" Interpolates the data using the given method. Args: method: interpolation method divide_over_direction: Divides the data into smaller chunks if the data is too large. **kwargs: Returns: interpolated data \"\"\" if not divide_over_direction : logger . info ( f \"Interpolating data based on { self . info } \" ) self . interpolated_data = griddata ( self . data [:, 0 : - 1 ], self . data [:, - 1 ], self . mesh , method = method , ** kwargs ) return self . get_data () else : logger . info ( f \"Dividing data into smaller chunks\" ) # Divide the data depending on the given direction # For now, only divide in the x direction using the mean value mesh_x_plus : np . ndarray = self . mesh [ self . mesh [:, 0 ] >= self . mesh [:, 0 ] . mean ()] mesh_x_minus : np . ndarray = self . mesh [ self . mesh [:, 0 ] < self . mesh [:, 0 ] . mean ()] data_x_plus : np . ndarray = self . data [ self . data [:, 0 ] >= self . data [:, 0 ] . mean ()] data_x_minus : np . ndarray = self . data [ self . data [:, 0 ] < self . data [:, 0 ] . mean ()] # Interpolate the data interpolate_plus = griddata ( data_x_plus [:, 0 : - 1 ], data_x_plus [:, - 1 ], mesh_x_plus , method = method , ** kwargs ) interpolate_minus = griddata ( data_x_minus [:, 0 : - 1 ], data_x_minus [:, - 1 ], mesh_x_minus , method = method , ** kwargs ) # Combine the data self . interpolated_data = np . concatenate (( interpolate_plus , interpolate_minus ), axis = 0 ) return self . get_data ()","title":"run()"},{"location":"docs-usage/","text":"Usage","title":"Usage examples"},{"location":"docs-usage/#usage","text":"","title":"Usage"}]}